<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Space Mission ‚Äì Land Safely!</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { 
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #0f0f23 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        #gameContainer {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameCanvas {
            border: 3px solid #333;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.3), inset 0 0 60px rgba(0,0,0,0.5);
            cursor: pointer;
            max-width: 100vw;
            max-height: 80vh;
            width: 100%;
            height: auto;
            object-fit: contain;
        }
        @media (max-width: 960px) {
            #gameCanvas {
                max-height: 70vh;
            }
        }
        @media (max-height: 600px) {
            #gameCanvas {
                max-height: 90vh;
            }
        }
        .touch-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            padding: 0 20px;
            justify-content: space-between;
            pointer-events: none;
        }
        .touch-controls.active { display: flex; }
        .touch-btn {
            pointer-events: all;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(76, 175, 80, 0.3);
            border: 3px solid rgba(76, 175, 80, 0.6);
            color: #4CAF50;
            font-size: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            transition: all 0.1s;
        }
        .touch-btn:active, .touch-btn.pressed {
            background: rgba(76, 175, 80, 0.6);
            transform: scale(0.95);
        }
        .touch-btn.thrust {
            width: 100px;
            height: 100px;
            background: rgba(255, 152, 0, 0.3);
            border-color: rgba(255, 152, 0, 0.6);
            color: #ff9800;
        }
        .touch-btn.thrust:active, .touch-btn.thrust.pressed {
            background: rgba(255, 152, 0, 0.6);
        }
        .touch-btn.shoot {
            width: 70px;
            height: 70px;
            background: rgba(255, 193, 7, 0.3);
            border-color: rgba(255, 193, 7, 0.6);
            color: #ffc107;
            position: absolute;
            right: 20px;
            top: 20px;
        }
        .touch-btn.shoot:active, .touch-btn.shoot.pressed {
            background: rgba(255, 193, 7, 0.6);
        }
        .side-btns { display: flex; gap: 15px; }
        .controls-hint {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 8px 16px;
            border-radius: 20px;
            color: #666;
            font-size: 12px;
        }
        .controls-hint code {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            color: #4CAF50;
        }
        /* Controles de Menu - Direcional Elegante (Apenas no Mobile) */
        .menu-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none; /* Escondido por padr√£o (desktop) */
            flex-direction: column;
            gap: 12px;
            z-index: 1000;
            align-items: flex-end;
        }
        
        /* Direcional (D-Pad) */
        .dpad-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .dpad {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 2px;
            width: 90px;
            height: 90px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            padding: 4px;
        }
        .dpad-btn {
            background: rgba(76, 175, 80, 0.5);
            border: 2px solid rgba(76, 175, 80, 0.9);
            color: #4CAF50;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.15s;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .dpad-btn:active {
            background: rgba(76, 175, 80, 0.9);
            transform: scale(0.9);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .dpad-btn.up {
            grid-column: 2;
            grid-row: 1;
        }
        .dpad-btn.down {
            grid-column: 2;
            grid-row: 3;
        }
        .dpad-btn.left {
            grid-column: 1;
            grid-row: 2;
        }
        .dpad-btn.right {
            grid-column: 3;
            grid-row: 2;
        }
        .dpad-middle {
            grid-column: 1 / 4;
            grid-row: 1 / 4;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            pointer-events: none;
        }
        .dpad-center {
            grid-column: 2;
            grid-row: 2;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 4px;
            pointer-events: none;
        }
        
        /* Bot√µes de A√ß√£o */
        .action-btns {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .action-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 22px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.15s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            border: 2px solid;
        }
        .action-btn:active {
            transform: scale(0.9);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .action-btn.select {
            background: rgba(255, 193, 7, 0.5);
            border-color: rgba(255, 193, 7, 0.9);
            color: #ffc107;
        }
        .action-btn.select:active {
            background: rgba(255, 193, 7, 0.9);
        }
        .action-btn.back {
            background: rgba(244, 67, 54, 0.5);
            border-color: rgba(244, 67, 54, 0.9);
            color: #f44336;
        }
        .action-btn.back:active {
            background: rgba(244, 67, 54, 0.9);
        }
        .menu-controls.hidden {
            display: none;
        }
        @media (max-width: 768px) {
            .controls-hint { display: none; }
            .menu-controls {
                display: flex; /* Mostra apenas no mobile */
                bottom: 15px;
                right: 15px;
            }
            .dpad {
                width: 80px;
                height: 80px;
            }
            .dpad-btn {
                font-size: 18px;
            }
            .action-btn {
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="960" height="540"></canvas>
    </div>
    
    <div class="touch-controls" id="touchControls">
        <div class="side-btns">
            <button class="touch-btn" id="btnLeft">‚Üê</button>
            <button class="touch-btn" id="btnRight">‚Üí</button>
            </div>
        <button class="touch-btn thrust" id="btnThrust">üî•</button>
        <button class="touch-btn shoot" id="btnShoot" style="display: none;">üí•</button>
        </div>
        
    <!-- Controles de Menu - Direcional Elegante para Mobile -->
    <div class="menu-controls" id="menuControls">
        <div class="dpad-container">
            <div class="dpad">
                <button class="dpad-btn up" id="btnMenuUp">‚Üë</button>
                <div class="dpad-middle">
                    <button class="dpad-btn left" id="btnMenuLeft">‚Üê</button>
                    <div class="dpad-center"></div>
                    <button class="dpad-btn right" id="btnMenuRight">‚Üí</button>
                </div>
                <button class="dpad-btn down" id="btnMenuDown">‚Üì</button>
            </div>
        </div>
        <div class="action-btns">
            <button class="action-btn select" id="btnMenuSelect">‚úì</button>
            <button class="action-btn back" id="btnMenuBack">‚úï</button>
        </div>
    </div>
    
    <div class="controls-hint">
        <code>SPACE</code>/<code>‚Üë</code> Thrust | <code>‚Üê</code><code>‚Üí</code> Move | <code>M</code> Mute | <code>L</code> Lang
    </div>
    
    <script>
    // ============================================
    // SPACE LANDER - COMPLETE ENHANCED VERSION
    // ============================================
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const W = 960, H = 540;
    
    // Polyfill for roundRect (if not supported)
    if (!ctx.roundRect) {
        ctx.roundRect = function(x, y, width, height, radius) {
            this.beginPath();
            this.moveTo(x + radius, y);
            this.lineTo(x + width - radius, y);
            this.quadraticCurveTo(x + width, y, x + width, y + radius);
            this.lineTo(x + width, y + height - radius);
            this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            this.lineTo(x + radius, y + height);
            this.quadraticCurveTo(x, y + height, x, y + height - radius);
            this.lineTo(x, y + radius);
            this.quadraticCurveTo(x, y, x + radius, y);
            this.closePath();
        };
    }
    
    // ============================================
    // AUDIO SYSTEM (Web Audio API)
    // ============================================
    class AudioSystem {
        constructor() {
            this.ctx = null;
            this.muted = false;
            this.sounds = {};
            this.musicGain = null;
            this.sfxGain = null;
            this.initialized = false;
            this.musicOscillators = [];
            this.currentMusic = null;
        }
        
        init() {
            if (this.initialized) return;
            try {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.musicGain = this.ctx.createGain();
                this.sfxGain = this.ctx.createGain();
                this.musicGain.connect(this.ctx.destination);
                this.sfxGain.connect(this.ctx.destination);
                this.musicGain.gain.value = 0.3;
                this.sfxGain.gain.value = 0.5;
                this.initialized = true;
            } catch(e) {
                console.log('Audio not supported');
            }
        }
        
        toggleMute() {
            this.muted = !this.muted;
            if (this.musicGain) this.musicGain.gain.value = this.muted ? 0 : 0.3;
            if (this.sfxGain) this.sfxGain.gain.value = this.muted ? 0 : 0.5;
            
            // M√∫sica removida
        }
        
        // Generate simple synth sounds
        playTone(freq, duration, type = 'sine', volume = 0.3) {
            if (!this.ctx || this.muted) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.value = volume;
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.sfxGain);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        }
        
        playThrust() {
            if (!this.ctx || this.muted) return;
            this.playTone(80 + Math.random() * 40, 0.05, 'sawtooth', 0.1);
        }
        
        playClick() {
            this.playTone(800, 0.05, 'square', 0.2);
        }
        
        playSuccess() {
            if (!this.ctx || this.muted) return;
            const notes = [523, 659, 784, 1047];
            notes.forEach((f, i) => {
                setTimeout(() => this.playTone(f, 0.3, 'sine', 0.3), i * 100);
            });
        }
        
        playCrash() {
            if (!this.ctx || this.muted) return;
            for (let i = 0; i < 5; i++) {
                setTimeout(() => this.playTone(100 + Math.random() * 200, 0.2, 'sawtooth', 0.4), i * 50);
            }
        }
        
        playPowerup() {
            this.playTone(880, 0.1, 'sine', 0.3);
            setTimeout(() => this.playTone(1100, 0.15, 'sine', 0.3), 100);
        }
        
        playLanding() {
            this.playTone(200, 0.3, 'sine', 0.2);
        }
        
        stopMusic() {
            this.musicOscillators.forEach(osc => {
                try { osc.stop(); } catch(e) {}
            });
            this.musicOscillators = [];
            this.currentMusic = null;
        }
        
    }
    
    const audio = new AudioSystem();
    
    // ============================================
    // PARTICLE SYSTEM
    // ============================================
    class Particle {
        constructor(x, y, vx, vy, color, life, size, type = 'circle') {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.color = color;
            this.life = life;
            this.maxLife = life;
            this.size = size;
            this.type = type;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotSpeed = (Math.random() - 0.5) * 0.2;
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.05; // slight gravity
            this.life--;
            this.rotation += this.rotSpeed;
        }
        
        draw(ctx) {
            const alpha = Math.max(0, this.life / this.maxLife);
            const radius = Math.max(0.1, this.size * alpha);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            if (this.type === 'circle') {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.type === 'star') {
                ctx.fillStyle = this.color;
                this.drawStar(ctx, 0, 0, 5, this.size, this.size / 2);
            } else if (this.type === 'square') {
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
            }
            
            ctx.restore();
        }
        
        drawStar(ctx, cx, cy, spikes, outerR, innerR) {
            let rot = Math.PI / 2 * 3;
            let step = Math.PI / spikes;
            ctx.beginPath();
            ctx.moveTo(cx, cy - outerR);
            for (let i = 0; i < spikes; i++) {
                ctx.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
                rot += step;
                ctx.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerR);
            ctx.closePath();
            ctx.fill();
        }
    }
    
    class ParticleSystem {
        constructor() {
            this.particles = [];
        }
        
        emit(x, y, count, config) {
            for (let i = 0; i < count; i++) {
                const angle = config.angle + (Math.random() - 0.5) * config.spread;
                const speed = config.speed * (0.5 + Math.random() * 0.5);
                this.particles.push(new Particle(
                    x + (Math.random() - 0.5) * (config.offsetX || 0),
                    y + (Math.random() - 0.5) * (config.offsetY || 0),
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    config.colors[Math.floor(Math.random() * config.colors.length)],
                    config.life * (0.5 + Math.random() * 0.5),
                    config.size * (0.5 + Math.random() * 0.5),
                    config.type || 'circle'
                ));
            }
        }
        
        emitThrust(x, y) {
            this.emit(x, y, 2, {
                angle: Math.PI / 2,
                spread: 0.5,
                speed: 3,
                life: 20,
                size: 6,
                colors: ['#ff6600', '#ffcc00', '#ff3300', '#ffff00'],
                offsetX: 10,
                offsetY: 5
            });
        }
        
        emitSideThrust(x, y, direction) {
            this.emit(x, y, 1, {
                angle: direction > 0 ? 0 : Math.PI,
                spread: 0.3,
                speed: 2,
                life: 15,
                size: 4,
                colors: ['#ff9900', '#ffcc00'],
                offsetX: 5,
                offsetY: 5
            });
        }
        
        emitExplosion(x, y) {
            this.emit(x, y, 50, {
                angle: 0,
                spread: Math.PI * 2,
                speed: 6,
                life: 40,
                size: 8,
                colors: ['#ff0000', '#ff6600', '#ffcc00', '#ff3300', '#ffffff'],
                type: 'circle'
            });
            // Debris
            this.emit(x, y, 20, {
                angle: -Math.PI / 2,
                spread: Math.PI,
                speed: 4,
                life: 60,
                size: 5,
                colors: ['#888888', '#666666', '#aaaaaa'],
                type: 'square'
            });
        }
        
        emitSuccess(x, y) {
            this.emit(x, y, 40, {
                angle: -Math.PI / 2,
                spread: Math.PI / 2,
                speed: 5,
                life: 60,
                size: 8,
                colors: ['#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#00BCD4'],
                type: 'star'
            });
        }
        
        emitConfetti(x, y) {
            this.emit(x, y, 3, {
                angle: -Math.PI / 2,
                spread: Math.PI / 3,
                speed: 4,
                life: 80,
                size: 6,
                colors: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7', '#fd79a8'],
                type: 'square'
            });
        }
        
        update() {
            this.particles = this.particles.filter(p => p.life > 0);
            this.particles.forEach(p => p.update());
        }
        
        draw(ctx) {
            this.particles.forEach(p => p.draw(ctx));
        }
        
        clear() {
            this.particles = [];
        }
    }
    
    const particles = new ParticleSystem();
    
    // ============================================
    // GAME STATE & CONSTANTS
    // ============================================
    let state = 'menu';
    let lang = 'en';
    let menuSel = 0;
    let levelSel = 0;
    let currentLevel = 0;
    let exploreCardSelected = -1; // -1 = none, 0-3 = card index
    let score = 0;
    let totalScore = 0;
    let failReason = '';
    let screenShake = 0;
    let flashAlpha = 0;
    let flashColor = '#ff0000';
    let transition = { active: false, alpha: 0, target: '', callback: null };
    let tutorialStep = 0;
    let showTutorial = true;
    let completedLevels = new Set(); // Rastreia quais n√≠veis foram completados nesta sess√£o
    let mascotMessage = '';
    let mascotTimer = 0;
    let isMobile = false;
    let highScores = JSON.parse(localStorage.getItem('spaceLanderScores') || '{"moon":[],"mars":[],"earth":[]}');
    
    // Trail system
    let trail = [];
    const MAX_TRAIL = 30;
    
    // Lander
    let lander = { x: W/2, y: 80, vx: 0, vy: 0, fuel: 100, thrust: false, shield: false, shieldTimer: 0, slowmo: false, slowmoTimer: 0, shieldCooldown: 0 };
    
    // Landing pad
    let padX = W/2 - 60;
    const PAD_W = 120, PAD_H = 15, PAD_Y = H - 50;
    const LANDER_W = 30, LANDER_H = 40;
    
    // Obstacles & Power-ups
    let obstacles = [];
    let powerups = [];
    let terrain = [];
    
    // Boss system (isolado - s√≥ usado quando level.boss === true)
    let bossActive = false;
    let bossData = null; // null quando n√£o h√° chefe
    let bossBullets = [];
    let playerBullets = [];
    let lastShotTime = 0;
    const SHOOT_COOLDOWN = 500; // 0.5 segundos entre tiros
    
    // Level configurations
    const LEVELS = [
        // Moon levels (1-3) - Progress√£o gradual de elementos
        { planet: 'moon', gravity: 0.025, fuel: 250, safeSpeed: 250, obstacles: 2, wind: 0, name: 'Moon 1' }, // Come√ßa com 2 obst√°culos (apenas asteroides)
        { planet: 'moon', gravity: 0.035, fuel: 220, safeSpeed: 180, obstacles: 3, wind: 0, name: 'Moon 2' }, // 3 obst√°culos (maioria asteroides, poucos aliens)
        { planet: 'moon', gravity: 0.045, fuel: 200, safeSpeed: 150, obstacles: 4, wind: 0.0005, name: 'Moon 3' }, // 4 obst√°culos (mistura de asteroides e aliens)
        // Mars levels (4-6) - Progress√£o aumentando
        { planet: 'mars', gravity: 0.07, fuel: 200, safeSpeed: 130, obstacles: 3, wind: 0.001, name: 'Mars 1' }, // 3 obst√°culos (alguns aliens)
        { planet: 'mars', gravity: 0.10, fuel: 160, safeSpeed: 100, obstacles: 5, wind: 0.002, name: 'Mars 2' }, // 5 obst√°culos (mais aliens)
        { planet: 'mars', gravity: 0.12, fuel: 140, safeSpeed: 90, obstacles: 6, wind: 0.003, name: 'Mars 3' }, // 6 obst√°culos (muitos aliens)
        // Earth levels (7-9) - M√âDIO/DIF√çCIL
        { planet: 'earth', gravity: 0.16, fuel: 220, safeSpeed: 100, obstacles: 2, wind: 0.002, name: 'Earth 1' }, // F√°cil
        { planet: 'earth', gravity: 0.22, fuel: 180, safeSpeed: 80, obstacles: 6, wind: 0.004, name: 'Earth 2' }, // Pouso mais f√°cil, mais obst√°culos
        { planet: 'earth', gravity: 0.26, fuel: 160, safeSpeed: 70, obstacles: 7, wind: 0.005, name: 'Earth 3' }, // Pouso mais f√°cil, mais obst√°culos
        // Boss Level (10) - CHEFE FINAL
        { planet: 'earth', gravity: 0.20, fuel: 300, safeSpeed: 80, obstacles: 0, wind: 0, name: 'Final Boss', boss: true }, // N√≠vel especial do chefe
    ];
    
    const PLANET_COLORS = {
        moon: { surface: '#b4b4be', sky: '#000000', accent: '#8a8a94' },
        mars: { surface: '#c86432', sky: '#1a0a05', accent: '#8b4513' },
        earth: { surface: '#3c8cc8', sky: '#000020', accent: '#2d6a9f' }
    };
    
    const THRUST_POWER = { moon: 0.30, mars: 0.28, earth: 0.40 }; // Thrust MUITO forte no Moon para facilitar
    const H_MOVE = { moon: 0.15, mars: 0.12, earth: 0.10 };
    const FUEL_RATE = 0.2; // Consome menos combust√≠vel
    
    // Texts
    const TEXTS = {
        en: {
            title: 'SPACE MISSION', subtitle: 'Land Safely!',
            play: 'Play', levels: 'Levels', tutorial: 'Tutorial', explore: 'Explore', info: 'Info', back: 'Back',
            moon: 'Moon', mars: 'Mars', earth: 'Earth',
            altitude: 'Alt', speed: 'Spd', fuel: 'Fuel',
            success: 'Perfect Landing!', score: 'Score', total: 'Total', again: 'SPACE = Continue',
            failure: 'Try Again!', tooFast: 'Too fast!', noFuel: 'Out of fuel!', missed: 'Missed!', hit: 'Hit obstacle!',
            controls: '‚Üë=thrust ‚Üê‚Üí=move',
            level: 'Level', locked: 'Locked', highscore: 'Best',
            tut1: 'Press UP or SPACE to thrust up!',
            tut2: 'Use LEFT/RIGHT to move sideways',
            tut3: 'Land slowly on the green pad!',
            mascot_fast: 'Slow down!', mascot_fuel: 'Save fuel!', mascot_aim: 'Aim for the pad!',
            mascot_good: 'Great job!', mascot_try: 'You can do it!',
            mascot_boss_shoot: 'Press X or Shift to shoot!', mascot_boss_weak: 'Aim for the green weak points!', mascot_boss_defeat: 'Defeat the boss first!',
            nextLevel: 'Next Level', menu: 'Menu',
            explore_gravity_title: 'What is Gravity?',
            explore_gravity_text: 'Gravity pulls everything down. On Earth, you don\'t float because gravity pulls you. In this game, your ship always falls because of gravity.',
            explore_moon_title: 'Moon',
            explore_moon_text: 'The Moon has weak gravity. Because of this, the ship falls slowly. That\'s why landing is easier in the game.',
            explore_mars_title: 'Mars',
            explore_mars_text: 'Mars has medium gravity. The ship falls faster than on the Moon. You need more care to land in the game.',
            explore_earth_title: 'Earth',
            explore_earth_text: 'Earth has strong gravity. The ship falls fast. This is the hardest level in the game!'
        },
        hu: {
            title: '≈∞RMISSZI√ì', subtitle: 'Sz√°llj le biztons√°gosan!',
            play: 'J√°t√©k', levels: 'P√°ly√°k', tutorial: 'Bemutat√≥', explore: 'Felfedez√©s', info: 'Inf√≥', back: 'Vissza',
            moon: 'Hold', mars: 'Mars', earth: 'F√∂ld',
            altitude: 'Mag', speed: 'Seb', fuel: '√územanyag',
            success: 'Sikeres Landol√°s!', score: 'Pont', total: '√ñssz', again: 'SPACE = Tov√°bb',
            failure: 'Pr√≥b√°ld √öjra!', tooFast: 'T√∫l gyorsan!', noFuel: 'Nincs √ºzemanyag!', missed: 'Rossz hely!', hit: '√útk√∂z√©s!',
            controls: '‚Üë=tol√°s ‚Üê‚Üí=mozg√°s',
            level: 'P√°lya', locked: 'Z√°rolva', highscore: 'Rekord',
            tut1: 'Nyomd a FEL-et vagy SPACE-t a tol√°shoz!',
            tut2: 'BAL/JOBB gombokkal oldalra mozoghatsz',
            tut3: 'Lassan sz√°llj le a z√∂ld platformra!',
            mascot_fast: 'Lass√≠ts!', mascot_fuel: 'Sp√≥rolj!', mascot_aim: 'C√©lozd a padot!',
            mascot_good: 'Szuper!', mascot_try: 'Menni fog!',
            mascot_boss_shoot: 'Nyomj X-et vagy Shift-et a l√∂v√©shez!', mascot_boss_weak: 'C√©lozd a z√∂ld gyenge pontokat!', mascot_boss_defeat: 'El≈ësz√∂r gy≈ëzd le a f≈ën√∂k√∂t!',
            nextLevel: 'K√∂vetkez≈ë', menu: 'Men√º',
            explore_gravity_title: 'Mi a gravit√°ci√≥?',
            explore_gravity_text: 'A gravit√°ci√≥ mindent lefel√© h√∫z. A F√∂ld√∂n nem lebegsz, mert a gravit√°ci√≥ h√∫z. Ebben a j√°t√©kban a haj√≥ mindig leesik a gravit√°ci√≥ miatt.',
            explore_moon_title: 'Hold',
            explore_moon_text: 'A Holdnak gyenge a gravit√°ci√≥ja. Emiatt a haj√≥ lassan esik. Ez√©rt k√∂nnyebb lesz√°llni a j√°t√©kban.',
            explore_mars_title: 'Mars',
            explore_mars_text: 'A Marsnak k√∂zepes a gravit√°ci√≥ja. A haj√≥ gyorsabban esik, mint a Holdon. T√∂bb figyelmet kell ford√≠tanod a lesz√°ll√°sra a j√°t√©kban.',
            explore_earth_title: 'F√∂ld',
            explore_earth_text: 'A F√∂ldnek er≈ës a gravit√°ci√≥ja. A haj√≥ gyorsan esik. Ez a legnehezebb p√°lya a j√°t√©kban!'
        }
    };
    const t = (key) => TEXTS[lang][key] || key;
    
    // Stars
    const stars = Array(120).fill().map(() => ({ 
        x: Math.random() * W, 
        y: Math.random() * (H - 100),
        size: Math.random() * 2 + 0.5,
        twinkle: Math.random() * Math.PI * 2,
        speed: Math.random() * 0.02 + 0.01
    }));
    
    // Shooting stars
    let shootingStars = [];
    
    // ============================================
    // INPUT HANDLING
    // ============================================
    const keys = {};
    const justPressed = {};
    let prevKeys = {};
    
    document.addEventListener('keydown', e => { 
        keys[e.code] = true; 
        e.preventDefault();
        audio.init();
    });
    document.addEventListener('keyup', e => { keys[e.code] = false; });
    
    // Touch controls
    function setupTouchControls() {
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');
        const btnThrust = document.getElementById('btnThrust');
        const btnShoot = document.getElementById('btnShoot');
        
        const handleTouch = (btn, code, isStart) => {
            keys[code] = isStart;
            btn.classList.toggle('pressed', isStart);
            if (isStart) audio.init();
        };
        
        btnLeft.addEventListener('touchstart', e => { e.preventDefault(); handleTouch(btnLeft, 'ArrowLeft', true); });
        btnLeft.addEventListener('touchend', e => { e.preventDefault(); handleTouch(btnLeft, 'ArrowLeft', false); });
        btnRight.addEventListener('touchstart', e => { e.preventDefault(); handleTouch(btnRight, 'ArrowRight', true); });
        btnRight.addEventListener('touchend', e => { e.preventDefault(); handleTouch(btnRight, 'ArrowRight', false); });
        btnThrust.addEventListener('touchstart', e => { e.preventDefault(); handleTouch(btnThrust, 'Space', true); });
        btnThrust.addEventListener('touchend', e => { e.preventDefault(); handleTouch(btnThrust, 'Space', false); });
        
        // Shoot button (single press, not hold) - isolado
        if (btnShoot) {
            const handleShoot = (e) => {
                e.preventDefault();
                audio.init();
                if (prevKeys['KeyX']) {
                    prevKeys['KeyX'] = false;
                }
                keys['KeyX'] = true;
                justPressed['KeyX'] = true;
                btnShoot.classList.add('pressed');
            setTimeout(() => {
                    keys['KeyX'] = false;
                    justPressed['KeyX'] = false;
                    btnShoot.classList.remove('pressed');
                }, 100);
            };
            btnShoot.addEventListener('touchstart', handleShoot);
            btnShoot.addEventListener('click', handleShoot);
        }
    }
    
    // Setup Menu Controls
    function setupMenuControls() {
        const btnMenuUp = document.getElementById('btnMenuUp');
        const btnMenuDown = document.getElementById('btnMenuDown');
        const btnMenuLeft = document.getElementById('btnMenuLeft');
        const btnMenuRight = document.getElementById('btnMenuRight');
        const btnMenuSelect = document.getElementById('btnMenuSelect');
        const btnMenuBack = document.getElementById('btnMenuBack');
        const menuControls = document.getElementById('menuControls');
        
        const handleMenuButton = (code) => {
            audio.init();
            // Garante que prevKeys n√£o tem essa tecla para que justPressed funcione
            if (prevKeys[code]) {
                prevKeys[code] = false;
            }
            // Simula pressionar a tecla - ser√° processado no pr√≥ximo frame
            keys[code] = true;
            justPressed[code] = true; // Marca como justPressed para funcionar imediatamente
            // Reseta ap√≥s processamento
            setTimeout(() => {
                keys[code] = false;
                justPressed[code] = false;
            }, 100);
        };
        
        btnMenuUp.addEventListener('click', () => handleMenuButton('ArrowUp'));
        btnMenuDown.addEventListener('click', () => handleMenuButton('ArrowDown'));
        btnMenuLeft.addEventListener('click', () => handleMenuButton('ArrowLeft'));
        btnMenuRight.addEventListener('click', () => handleMenuButton('ArrowRight'));
        btnMenuSelect.addEventListener('click', () => handleMenuButton('Enter'));
        btnMenuBack.addEventListener('click', () => handleMenuButton('Escape'));
        
        // Mostra/esconde controles baseado no estado (apenas no mobile, CSS cuida do desktop)
        const updateMenuControls = () => {
            const showInStates = ['menu', 'levelSelect', 'explore', 'success', 'failure', 'info', 'tutorialMode'];
            // S√≥ atualiza se for mobile (no desktop o CSS j√° esconde)
            if (isMobile) {
                if (showInStates.includes(state)) {
                    menuControls.classList.remove('hidden');
                } else {
                    menuControls.classList.add('hidden');
                }
            }
        };
        
        // Atualiza a cada frame
        setInterval(updateMenuControls, 100);
    }
    
    // Detect mobile
    function detectMobile() {
        isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        document.getElementById('touchControls').classList.toggle('active', isMobile && state === 'playing');
    }
    
    // Click to start on menu and level select
    canvas.addEventListener('click', (e) => { 
        audio.init();
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        
        if (state === 'menu') {
            // Calculate which menu item was clicked
            const menuStartY = 220;
            const menuSpacing = 65;
            
            for (let i = 0; i < 5; i++) {
                const itemY = menuStartY + i * menuSpacing;
                if (clickY >= itemY - 25 && clickY <= itemY + 25) {
                    menuSel = i;
                    audio.playClick();
                    if (menuSel === 0) startTransition('playing', () => startLevel(0));
                    else if (menuSel === 1) { state = 'levelSelect'; levelSel = 0; }
                    else if (menuSel === 2) { state = 'tutorialMode'; tutorialStep = 0; }
                    else if (menuSel === 3) { state = 'explore'; exploreCardSelected = -1; menuSel = 0; }
                    else state = 'info';
                    break;
                }
            }
        } else if (state === 'levelSelect') {
            // Detect click on level cards (3x3 grid)
            for (let i = 0; i < 9; i++) {
                const col = i % 3;
                const row = Math.floor(i / 3);
                const x = 200 + col * 200;
                const y = 150 + row * 110;
                
                if (clickX >= x - 70 && clickX <= x + 70 && 
                    clickY >= y - 35 && clickY <= y + 45) {
                    levelSel = i;
                    audio.playClick();
                    if (levelSel < LEVELS.length) startTransition('playing', () => startLevel(levelSel));
                    break;
                }
            }
            // Check back button
            if (clickY >= H - 60 && clickY <= H - 20) {
                state = 'menu';
                audio.playClick();
            }
        } else if (state === 'explore' && exploreCardSelected === -1) {
            // Detect click on explore cards (2x2 grid)
            const cards = [
                { x: 120, y: 120 },
                { x: 520, y: 120 },
                { x: 120, y: 300 },
                { x: 520, y: 300 }
            ];
            
            for (let i = 0; i < 4; i++) {
                const card = cards[i];
                if (clickX >= card.x && clickX <= card.x + 320 &&
                    clickY >= card.y && clickY <= card.y + 140) {
                    menuSel = i;
                    exploreCardSelected = i;
                    audio.playClick();
                    break;
                }
            }
        }
    });
    
    // Touch navigation for menus (swipe up/down, tap to select)
    let touchStartY = 0;
    let touchStartX = 0;
    
    canvas.addEventListener('touchstart', (e) => {
        if (state === 'menu' || state === 'levelSelect' || state === 'explore') {
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
        }
    }, { passive: true });
    
    canvas.addEventListener('touchend', (e) => {
        if (state === 'menu' || state === 'levelSelect' || state === 'explore') {
            const touchEndY = e.changedTouches[0].clientY;
            const touchEndX = e.changedTouches[0].clientX;
            const diffY = touchStartY - touchEndY;
            const diffX = Math.abs(touchStartX - touchEndX);
            
            // Only process if vertical swipe (not horizontal)
            if (Math.abs(diffY) > Math.abs(diffX) && Math.abs(diffY) > 20) {
                // Swipe up = previous item
                if (diffY < -20) {
                    if (state === 'menu') {
                        menuSel = (menuSel + 4) % 5;
                        audio.playClick();
                    } else if (state === 'levelSelect') {
                        levelSel = Math.max(0, levelSel - 3);
                        audio.playClick();
                    } else if (state === 'explore' && exploreCardSelected === -1) {
                        menuSel = menuSel >= 2 ? menuSel - 2 : menuSel + 2;
                        audio.playClick();
                    }
                }
                // Swipe down = next item
                else if (diffY > 20) {
                    if (state === 'menu') {
                        menuSel = (menuSel + 1) % 5;
                        audio.playClick();
                    } else if (state === 'levelSelect') {
                        const maxLevel = LEVELS.length - 1;
                        levelSel = Math.min(maxLevel, levelSel + 3);
                        audio.playClick();
                    } else if (state === 'explore' && exploreCardSelected === -1) {
                        menuSel = menuSel < 2 ? menuSel + 2 : menuSel - 2;
                        audio.playClick();
                    }
                }
            }
            // Tap (small movement) = select
            else if (Math.abs(diffY) < 15 && Math.abs(diffX) < 15) {
                if (state === 'menu') {
                    audio.playClick();
                    if (menuSel === 0) startTransition('playing', () => startLevel(0));
                    else if (menuSel === 1) { state = 'levelSelect'; levelSel = 0; }
                    else if (menuSel === 2) { state = 'tutorialMode'; tutorialStep = 0; }
                    else if (menuSel === 3) { state = 'explore'; exploreCardSelected = -1; menuSel = 0; }
                    else state = 'info';
                } else if (state === 'levelSelect') {
                    audio.playClick();
                    if (levelSel < LEVELS.length) startTransition('playing', () => startLevel(levelSel));
                    else state = 'menu';
                } else if (state === 'explore' && exploreCardSelected === -1) {
                    audio.playClick();
                    exploreCardSelected = menuSel;
                }
            }
        }
    }, { passive: true });
    
    // ============================================
    // LEVEL MANAGEMENT
    // ============================================
    function generateTerrain(planet, landerX) {
        terrain = [];
        const baseY = H - 45;
        let x = 0;
        while (x < W) {
            const height = 10 + Math.random() * 25;
            const width = 40 + Math.random() * 60;
            // Keep terrain away from pad and lander start position
            const nearPad = (x + width > padX - 30 && x < padX + PAD_W + 30);
            const nearLander = (x + width > landerX - 50 && x < landerX + 50);
            if (!nearPad && !nearLander) {
                terrain.push({ x, y: baseY, width, height });
            }
            x += width + Math.random() * 30;
        }
    }
    
    function generateObstacles(count, landerX) {
        obstacles = [];
        for (let i = 0; i < count; i++) {
            let x, y;
            let attempts = 0;
            do {
                x = 80 + Math.random() * (W - 160);
                y = 150 + Math.random() * (H - 300);
                attempts++;
            } while (attempts < 50 && (
                Math.abs(x - padX - PAD_W/2) < 150 ||  // Keep away from pad
                (Math.abs(x - landerX) < 100 && y < 200) // Keep away from lander start
            ));
            
            if (attempts < 50) {
                // Progress√£o gradual de alien√≠genas por n√≠vel
                // Moon 1 (0): 0%, Moon 2 (1): 10%, Moon 3 (2): 20%
                // Mars 1 (3): 25%, Mars 2 (4): 30%, Mars 3 (5): 35%
                // Earth 1 (6): 30%, Earth 2 (7): 35%, Earth 3 (8): 40%
                const alienChance = [
                    0.0,  // Moon 1 - apenas asteroides
                    0.1,  // Moon 2 - 10% aliens
                    0.2,  // Moon 3 - 20% aliens
                    0.25, // Mars 1 - 25% aliens
                    0.3,  // Mars 2 - 30% aliens
                    0.35, // Mars 3 - 35% aliens
                    0.3,  // Earth 1 - 30% aliens
                    0.35, // Earth 2 - 35% aliens
                    0.4   // Earth 3 - 40% aliens
                ];
                // Velocidade de persegui√ß√£o tamb√©m aumenta gradualmente
                const chaseSpeeds = [
                    0.0,   // Moon 1 - sem persegui√ß√£o
                    0.005, // Moon 2 - persegui√ß√£o muito suave
                    0.008, // Moon 3 - persegui√ß√£o suave
                    0.010, // Mars 1 - persegui√ß√£o moderada
                    0.012, // Mars 2 - persegui√ß√£o moderada-alta
                    0.015, // Mars 3 - persegui√ß√£o normal
                    0.015, // Earth 1 - persegui√ß√£o normal
                    0.018, // Earth 2 - persegui√ß√£o mais agressiva
                    0.020  // Earth 3 - persegui√ß√£o mais agressiva
                ];
                
                const alienProbability = alienChance[currentLevel] || 0;
                const isAlien = Math.random() < alienProbability;
                const chaseSpeed = isAlien ? (chaseSpeeds[currentLevel] || 0.015) : 0;
                
                obstacles.push({
                    x, y,
                    radius: isAlien ? (12 + Math.random() * 12) : (20 + Math.random() * 20), // Alien√≠genas menores: 12-24, Asteroides: 20-40
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.3,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.02,
                    type: isAlien ? 'alien' : 'asteroid',
                    chaseSpeed: chaseSpeed
                });
            }
        }
    }
    
    function spawnPowerup() {
        if (powerups.length >= 2 || Math.random() > 0.01) return;
        const types = ['fuel', 'shield', 'slowmo'];
        powerups.push({
            x: 100 + Math.random() * (W - 200),
            y: 100 + Math.random() * (H - 300),
            type: types[Math.floor(Math.random() * types.length)],
            bobOffset: Math.random() * Math.PI * 2
        });
    }
    
    function startLevel(levelIndex) {
        currentLevel = levelIndex;
        const level = LEVELS[levelIndex];
        
        // Clear everything first
        obstacles = [];
        terrain = [];
        powerups = [];
        trail = [];
        particles.clear();
        screenShake = 0;
        tutorialStep = 0;
        
        // Set pad position
        padX = 100 + Math.random() * (W - 200 - PAD_W);
        
        // Set lander start position
        const startX = 150 + Math.random() * (W - 300);
        
        lander = { 
            x: startX, y: 60, vx: 0, vy: 0, 
            fuel: level.fuel, 
            thrust: false, 
            shield: false, shieldTimer: 0, shieldCooldown: 0,
            slowmo: false, slowmoTimer: 0,
            spawnProtection: 60 // 1 second of spawn protection
        };
        
        // Generate terrain AFTER setting lander position
        generateTerrain(level.planet, startX);
        generateObstacles(level.obstacles, startX);
        
        // Initialize boss if this is a boss level (isolado - n√£o modifica c√≥digo existente)
        if (level.boss) {
            bossActive = true;
            bossData = {
                x: W / 2,
                y: 100,
                vx: 0.8,
                health: 100,
                maxHealth: 100,
                shootTimer: 0,
                phase: 1, // 1, 2, or 3
                width: 120,
                height: 80,
                weakPoints: [
                    { x: -40, y: 20, radius: 15, health: 33 },
                    { x: 0, y: 10, radius: 15, health: 33 },
                    { x: 40, y: 20, radius: 15, health: 33 }
                ]
            };
            bossBullets = [];
            playerBullets = [];
            lastShotTime = 0;
            // Pad appears only after boss is defeated
            padX = W / 2 - PAD_W / 2;
        } else {
            bossActive = false;
            bossData = null;
            bossBullets = [];
            playerBullets = [];
        }
        
        state = 'playing';
        document.getElementById('touchControls').classList.toggle('active', isMobile);
    }
    
    function startTransition(target, callback) {
        transition = { active: true, alpha: 0, target, callback, fadeIn: true };
    }
    
    // ============================================
    // COLLISION DETECTION
    // ============================================
    function checkCollisions() {
        // Skip collisions during spawn protection
        if (lander.spawnProtection > 0) {
            lander.spawnProtection--;
            return null;
        }
        
        // Skip collisions during shield cooldown (brief invulnerability after shield is consumed)
        if (lander.shieldCooldown > 0) {
            lander.shieldCooldown--;
            return null;
        }
        
        const level = LEVELS[currentLevel];
        
        // Check obstacle collisions
        for (let obs of obstacles) {
            const dx = lander.x - obs.x;
            const dy = lander.y - obs.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < obs.radius + LANDER_W/2) {
                if (lander.shield) {
                    lander.shield = false;
                    lander.shieldCooldown = 30; // 30 frames de invulnerabilidade ap√≥s escudo ser consumido
                    // Empurra a nave para fora do obst√°culo de forma mais agressiva
                    const angle = Math.atan2(dy, dx);
                    const pushDistance = obs.radius + LANDER_W/2 - dist + 10; // Empurra 10px al√©m do obst√°culo
                    lander.x += Math.cos(angle) * pushDistance;
                    lander.y += Math.sin(angle) * pushDistance;
                    lander.vx = Math.cos(angle) * 0.5; // Bounce mais forte
                    lander.vy = Math.sin(angle) * 0.5;
                    particles.emit(lander.x, lander.y, 15, {
                        angle: angle, spread: 1, speed: 4, life: 25, size: 6,
                        colors: ['#4a9eff', '#ffffff']
                    });
                    audio.playPowerup();
                    return null; // Protegido, n√£o retorna 'hit'
                } else {
                    return 'hit';
                }
            }
        }
        
        // Check terrain collisions
        for (let t of terrain) {
            if (lander.x > t.x && lander.x < t.x + t.width && 
                lander.y + LANDER_H/2 > t.y - t.height) {
                if (lander.shield) {
                    lander.shield = false;
                    lander.shieldCooldown = 30; // 30 frames de invulnerabilidade ap√≥s escudo ser consumido
                    // Empurra a nave para fora do terreno de forma mais agressiva
                    lander.y = t.y - t.height - LANDER_H/2 - 5; // Empurra 5px acima do terreno
                    lander.vy = -0.8; // Bounce mais forte
                    lander.vx += (Math.random() - 0.5) * 0.3;
                    particles.emit(lander.x, lander.y, 15, {
                        angle: Math.PI / 2, spread: 0.5, speed: 4, life: 25, size: 6,
                        colors: ['#4a9eff', '#ffffff']
                    });
                    audio.playPowerup();
                    return null; // Protegido, n√£o retorna 'hit'
                } else {
                    return 'hit';
                }
            }
        }
        
        return null;
    }
    
    function checkPowerupCollision() {
        for (let i = powerups.length - 1; i >= 0; i--) {
            const p = powerups[i];
            const dx = lander.x - p.x;
            const dy = lander.y - p.y;
            if (Math.sqrt(dx*dx + dy*dy) < 30) {
                audio.playPowerup();
                particles.emit(p.x, p.y, 15, {
                    angle: 0, spread: Math.PI * 2, speed: 3, life: 25, size: 6,
                    colors: ['#4CAF50', '#ffeb3b', '#00bcd4'],
                    type: 'star'
                });
                
                if (p.type === 'fuel') {
                    lander.fuel = Math.min(lander.fuel + 30, LEVELS[currentLevel].fuel);
                    showMascot(t('mascot_good'));
                } else if (p.type === 'shield') {
                    lander.shield = true;
                    lander.shieldTimer = 300;
                } else if (p.type === 'slowmo') {
                    lander.slowmo = true;
                    lander.slowmoTimer = 180;
                }
                
                powerups.splice(i, 1);
            }
        }
    }
    
    // ============================================
    // MASCOT SYSTEM
    // ============================================
    function showMascot(msg) {
        mascotMessage = msg;
        mascotTimer = 120;
    }
    
    function updateMascot() {
        if (mascotTimer > 0) mascotTimer--;
        
        // Auto hints
        if (state === 'playing' && mascotTimer === 0) {
            const totalSpeed = Math.sqrt(lander.vx*lander.vx + lander.vy*lander.vy) * 100;
            const level = LEVELS[currentLevel];
            
            // Boss level specific hints
            if (level.boss && bossActive && bossData) {
                if (!bossData.defeated && Math.random() < 0.03) {
                    // Show shooting hint if player hasn't shot recently
                    const timeSinceLastShot = Date.now() - lastShotTime;
                    if (timeSinceLastShot > 3000 && playerBullets.length === 0) {
                        showMascot(t('mascot_boss_shoot'));
                    } else if (bossData.health > 50 && Math.random() < 0.5) {
                        showMascot(t('mascot_boss_weak'));
                    } else {
                        showMascot(t('mascot_boss_defeat'));
                    }
                }
            } else {
                // Normal level hints
                if (totalSpeed > level.safeSpeed * 1.5 && Math.random() < 0.02) {
                    showMascot(t('mascot_fast'));
                } else if (lander.fuel < level.fuel * 0.2 && Math.random() < 0.02) {
                    showMascot(t('mascot_fuel'));
                } else if (Math.abs(lander.x - (padX + PAD_W/2)) > 200 && Math.random() < 0.01) {
                    showMascot(t('mascot_aim'));
                }
            }
        }
    }
    
    // ============================================
    // DRAWING FUNCTIONS
    // ============================================
    function drawBackground(planet) {
        const colors = PLANET_COLORS[planet];
        
        // Sky gradient
        const grad = ctx.createLinearGradient(0, 0, 0, H);
        grad.addColorStop(0, colors.sky);
        grad.addColorStop(1, colors.accent + '40');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
        
        // Stars with twinkle
        stars.forEach(s => {
            s.twinkle += s.speed;
            const alpha = 0.5 + Math.sin(s.twinkle) * 0.5;
            ctx.fillStyle = `rgba(255,255,255,${alpha})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // Shooting stars
        if (Math.random() < 0.005) {
            shootingStars.push({
                x: Math.random() * W,
                y: Math.random() * 100,
                vx: 5 + Math.random() * 5,
                vy: 2 + Math.random() * 2,
                life: 30
            });
        }
        shootingStars = shootingStars.filter(s => s.life > 0);
        shootingStars.forEach(s => {
            s.x += s.vx;
            s.y += s.vy;
            s.life--;
            ctx.strokeStyle = `rgba(255,255,255,${s.life / 30})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(s.x, s.y);
            ctx.lineTo(s.x - s.vx * 3, s.y - s.vy * 3);
            ctx.stroke();
        });
        
        // Planet surface
        ctx.fillStyle = colors.surface;
        ctx.beginPath();
        ctx.ellipse(W/2, H - 20, W/2 + 50, 100, 0, Math.PI, 0);
        ctx.fill();
        
        // Surface texture/craters
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        for (let i = 0; i < 10; i++) {
            const cx = 60 + i * 95;
            const cy = H - 40 + Math.sin(i * 1.7) * 15;
            ctx.beginPath();
            ctx.arc(cx, cy, 12 + (i % 4) * 6, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    function drawTerrain(planet) {
        const colors = PLANET_COLORS[planet];
        ctx.fillStyle = colors.accent;
        terrain.forEach(t => {
            ctx.beginPath();
            ctx.moveTo(t.x, t.y);
            ctx.lineTo(t.x + t.width/2, t.y - t.height);
            ctx.lineTo(t.x + t.width, t.y);
            ctx.closePath();
            ctx.fill();
        });
    }
    
    function drawPad() {
        // Target arrow
        const time = Date.now() / 200;
        const bobY = Math.sin(time) * 5;
        ctx.fillStyle = '#ffeb3b';
        ctx.beginPath();
        ctx.moveTo(padX + PAD_W/2, PAD_Y - 40 + bobY);
        ctx.lineTo(padX + PAD_W/2 - 12, PAD_Y - 55 + bobY);
        ctx.lineTo(padX + PAD_W/2 + 12, PAD_Y - 55 + bobY);
        ctx.closePath();
        ctx.fill();
        
        // Glow effect
        ctx.shadowColor = '#4CAF50';
        ctx.shadowBlur = 15;
        
        // Pad base
        ctx.fillStyle = '#444';
        ctx.fillRect(padX - 5, PAD_Y + 5, PAD_W + 10, PAD_H);
        
        // Pad surface
        ctx.fillStyle = '#666';
        ctx.fillRect(padX, PAD_Y, PAD_W, PAD_H);
        
        // Green landing zone
        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(padX + 15, PAD_Y, PAD_W - 30, PAD_H);
        
        // Stripes
        ctx.fillStyle = '#388E3C';
        for (let i = 0; i < 3; i++) {
            ctx.fillRect(padX + 25 + i * 25, PAD_Y + 3, 8, PAD_H - 6);
        }
        
        ctx.shadowBlur = 0;
        
        // Lights
        const lightOn = Math.sin(time * 2) > 0;
        ctx.fillStyle = lightOn ? '#ffeb3b' : '#665500';
        ctx.beginPath();
        ctx.arc(padX + 8, PAD_Y + PAD_H/2, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(padX + PAD_W - 8, PAD_Y + PAD_H/2, 5, 0, Math.PI * 2);
        ctx.fill();
    }
    
    function drawObstacles() {
        obstacles.forEach(obs => {
            // Alien chase behavior - move towards lander when close
            if (obs.type === 'alien' && obs.chaseSpeed > 0) {
                const dx = lander.x - obs.x;
                const dy = lander.y - obs.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 0 && dist < 300) {
                    // Suave persegui√ß√£o - adiciona velocidade em dire√ß√£o √† nave
                    obs.vx += (dx / dist) * obs.chaseSpeed;
                    obs.vy += (dy / dist) * obs.chaseSpeed;
                    // Limita velocidade m√°xima
                    const maxSpeed = 1.0;
                    const speed = Math.sqrt(obs.vx*obs.vx + obs.vy*obs.vy);
                    if (speed > maxSpeed) {
                        obs.vx = (obs.vx / speed) * maxSpeed;
                        obs.vy = (obs.vy / speed) * maxSpeed;
                    }
                }
            }
            
            obs.x += obs.vx;
            obs.y += obs.vy;
            obs.rotation += obs.rotSpeed;
            
            // Bounce off edges
            if (obs.x < obs.radius || obs.x > W - obs.radius) obs.vx *= -1;
            if (obs.y < obs.radius + 50 || obs.y > H - 150) obs.vy *= -1;
            
            ctx.save();
            ctx.translate(obs.x, obs.y);
            ctx.rotate(obs.rotation);
            
            // Alien ou Asteroid - desenhos completamente diferentes
            if (obs.type === 'alien') {
                // NAVE ALIEN√çGENA - Design equilibrado e harmonioso
                // Corpo principal - formato triangular similar √† nave do jogador, mas invertido
                ctx.fillStyle = '#8b5cf6'; // Roxo suave
                ctx.beginPath();
                ctx.moveTo(0, obs.radius * 0.7); // Parte inferior
                ctx.lineTo(-obs.radius * 0.7, -obs.radius * 0.5); // Esquerda
                ctx.lineTo(0, -obs.radius * 0.8); // Topo
                ctx.lineTo(obs.radius * 0.7, -obs.radius * 0.5); // Direita
                ctx.closePath();
                ctx.fill();
                
                // Borda sutil
                ctx.strokeStyle = '#6d28d9';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // C√∫pula/cockpit central - similar √† nave do jogador
                ctx.fillStyle = '#a78bfa';
                ctx.beginPath();
                ctx.arc(0, -obs.radius * 0.3, obs.radius * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Brilho na c√∫pula
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.arc(-obs.radius * 0.08, -obs.radius * 0.35, obs.radius * 0.08, 0, Math.PI * 2);
                ctx.fill();
                
                // Asas laterais menores e mais discretas
                ctx.fillStyle = '#7c3aed';
                ctx.beginPath();
                // Asa esquerda
                ctx.moveTo(-obs.radius * 0.4, -obs.radius * 0.2);
                ctx.lineTo(-obs.radius * 0.9, obs.radius * 0.3);
                ctx.lineTo(-obs.radius * 0.5, obs.radius * 0.4);
                ctx.closePath();
                ctx.fill();
                // Asa direita
                ctx.beginPath();
                ctx.moveTo(obs.radius * 0.4, -obs.radius * 0.2);
                ctx.lineTo(obs.radius * 0.9, obs.radius * 0.3);
                ctx.lineTo(obs.radius * 0.5, obs.radius * 0.4);
                ctx.closePath();
                ctx.fill();
                
                // Propulsores sutis na parte traseira
                ctx.fillStyle = '#c084fc';
                ctx.beginPath();
                ctx.arc(-obs.radius * 0.3, obs.radius * 0.5, obs.radius * 0.12, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(obs.radius * 0.3, obs.radius * 0.5, obs.radius * 0.12, 0, Math.PI * 2);
                ctx.fill();
                
                // Olhos/ilumina√ß√£o frontal - mais sutis
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(-obs.radius * 0.2, -obs.radius * 0.5, 2.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(obs.radius * 0.2, -obs.radius * 0.5, 2.5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Asteroid - cor cinza (mant√©m o formato original)
                ctx.fillStyle = '#666';
                ctx.shadowBlur = 0;
                
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const r = obs.radius * (0.8 + Math.sin(i * 3) * 0.2);
                    if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                    else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                }
                ctx.closePath();
                ctx.fill();
                
                // Craters do asteroide
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.arc(obs.radius * 0.3, -obs.radius * 0.2, obs.radius * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-obs.radius * 0.2, obs.radius * 0.3, obs.radius * 0.15, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        });
    }
    
    function drawPowerups() {
        const time = Date.now() / 200;
        powerups.forEach(p => {
            const bobY = Math.sin(time + p.bobOffset) * 5;
            
            ctx.save();
            ctx.translate(p.x, p.y + bobY);
            
            // Glow
            ctx.shadowColor = p.type === 'fuel' ? '#4CAF50' : p.type === 'shield' ? '#2196F3' : '#9C27B0';
            ctx.shadowBlur = 15;
            
            // Icon background
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(0, 0, 18, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = p.type === 'fuel' ? '#4CAF50' : p.type === 'shield' ? '#2196F3' : '#9C27B0';
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Icon
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const icons = { fuel: '‚õΩ', shield: 'üõ°', slowmo: '‚è±' };
            ctx.fillText(icons[p.type], 0, 0);
            
            ctx.shadowBlur = 0;
            ctx.restore();
        });
    }
    
    function drawTrail() {
        if (trail.length < 2) return;
        
        ctx.strokeStyle = 'rgba(76, 175, 80, 0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(trail[0].x, trail[0].y);
        for (let i = 1; i < trail.length; i++) {
            ctx.lineTo(trail[i].x, trail[i].y);
        }
        ctx.stroke();
        
        // Trail dots
        trail.forEach((p, i) => {
            const alpha = i / trail.length * 0.5;
            ctx.fillStyle = `rgba(76, 175, 80, ${alpha})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    // ============================================
    // BOSS DRAWING FUNCTIONS (Isoladas)
    // ============================================
    function drawBoss() {
        if (!bossData || !bossActive) return;
        
        ctx.save();
        ctx.translate(bossData.x, bossData.y);
        
        // Boss body - nave alien√≠gena gigante
        const phaseColor = bossData.phase === 1 ? '#9b5cf6' : bossData.phase === 2 ? '#7c3aed' : '#6d28d9';
        ctx.fillStyle = phaseColor;
        ctx.shadowBlur = 15;
        ctx.shadowColor = phaseColor;
        
        // Corpo principal (triangular invertido)
        ctx.beginPath();
        ctx.moveTo(0, -bossData.height/2);
        ctx.lineTo(-bossData.width/2, bossData.height/2);
        ctx.lineTo(0, bossData.height/2 - 20);
        ctx.lineTo(bossData.width/2, bossData.height/2);
        ctx.closePath();
        ctx.fill();
        
        // Detalhes
        ctx.fillStyle = '#a78bfa';
        ctx.beginPath();
        ctx.arc(0, -bossData.height/4, bossData.width/6, 0, Math.PI * 2);
        ctx.fill();
        
        // Weak points (mudam de cor conforme a vida)
        bossData.weakPoints.forEach((wp, i) => {
            const wx = wp.x;
            const wy = wp.y;
            const healthPct = wp.health / 33;
            let color = '#4CAF50'; // Verde quando saud√°vel
            if (healthPct < 0.5) color = '#ffeb3b'; // Amarelo quando m√©dio
            if (healthPct < 0.25) color = '#ff5252'; // Vermelho quando fraco
            
            ctx.fillStyle = color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.beginPath();
            ctx.arc(wx, wy, wp.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Brilho pulsante
            ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.sin(Date.now()/200 + i) * 0.2})`;
            ctx.beginPath();
            ctx.arc(wx, wy, wp.radius * 0.6, 0, Math.PI * 2);
            ctx.fill();
        });
        
        ctx.shadowBlur = 0;
        ctx.restore();
    }
    
    function drawBossBullets() {
        if (!bossActive) return;
        
        // Player bullets
        ctx.fillStyle = '#ffeb3b';
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#ff9800';
        playerBullets.forEach(bullet => {
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
            ctx.fill();
            // Trail
            ctx.fillStyle = 'rgba(255, 235, 59, 0.3)';
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y + 5, bullet.radius * 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffeb3b';
        });
        
        // Boss bullets
        ctx.fillStyle = '#9c27b0';
        ctx.shadowColor = '#7b1fa2';
        bossBullets.forEach(bullet => {
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
            ctx.fill();
            // Trail
            ctx.fillStyle = 'rgba(156, 39, 176, 0.3)';
            ctx.beginPath();
            ctx.arc(bullet.x - bullet.vx * 2, bullet.y - bullet.vy * 2, bullet.radius * 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#9c27b0';
        });
        
        ctx.shadowBlur = 0;
    }
    
    function drawLander() {
        const x = lander.x, y = lander.y;
        
        // Shadow
        const shadowY = PAD_Y + 5;
        const shadowScale = Math.max(0.2, 1 - (shadowY - y) / 400);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(x, shadowY, LANDER_W/2 * shadowScale, 4 * shadowScale, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Shield effect
        if (lander.shield) {
            ctx.strokeStyle = `rgba(74, 158, 255, ${0.5 + Math.sin(Date.now()/100) * 0.3})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, LANDER_W, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Slowmo effect - mais vis√≠vel e forte
        if (lander.slowmo) {
            // C√≠rculo externo pulsante maior
            ctx.fillStyle = `rgba(156, 39, 176, ${0.35 + Math.sin(Date.now()/100) * 0.15})`;
            ctx.beginPath();
            ctx.arc(x, y, LANDER_W * 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // C√≠rculo interno mais brilhante
            ctx.fillStyle = `rgba(200, 100, 255, ${0.4 + Math.sin(Date.now()/80) * 0.2})`;
            ctx.beginPath();
            ctx.arc(x, y, LANDER_W * 1.8, 0, Math.PI * 2);
            ctx.fill();
            
            // Brilho adicional
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#9c27b0';
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.6 + Math.sin(Date.now()/120) * 0.3})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, LANDER_W * 2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        // Main body
        ctx.fillStyle = '#e8e8e8';
        ctx.beginPath();
        ctx.moveTo(x, y - LANDER_H/2);
        ctx.lineTo(x - LANDER_W/2, y + LANDER_H/2);
        ctx.lineTo(x + LANDER_W/2, y + LANDER_H/2);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Window
        ctx.fillStyle = '#4a9eff';
        ctx.beginPath();
        ctx.arc(x, y - 5, 10, 0, Math.PI * 2);
        ctx.fill();
        
        // Window shine
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.arc(x - 3, y - 8, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Landing legs
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x - LANDER_W/2 + 5, y + LANDER_H/2);
        ctx.lineTo(x - LANDER_W/2 - 8, y + LANDER_H/2 + 12);
        ctx.moveTo(x + LANDER_W/2 - 5, y + LANDER_H/2);
        ctx.lineTo(x + LANDER_W/2 + 8, y + LANDER_H/2 + 12);
        ctx.stroke();
        
        // Feet
        ctx.fillStyle = '#444';
        ctx.beginPath();
        ctx.arc(x - LANDER_W/2 - 8, y + LANDER_H/2 + 12, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + LANDER_W/2 + 8, y + LANDER_H/2 + 12, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Thrust flames (drawn by particle system now)
        if (lander.thrust && lander.fuel > 0) {
            const flameLen = 18 + Math.random() * 12;
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.moveTo(x - 10, y + LANDER_H/2);
            ctx.lineTo(x, y + LANDER_H/2 + flameLen);
            ctx.lineTo(x + 10, y + LANDER_H/2);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.moveTo(x - 5, y + LANDER_H/2);
            ctx.lineTo(x, y + LANDER_H/2 + flameLen * 0.6);
            ctx.lineTo(x + 5, y + LANDER_H/2);
            ctx.closePath();
            ctx.fill();
        }
        
        // Side thrusters
        const leftThrust = keys['ArrowLeft'] || keys['KeyA'];
        const rightThrust = keys['ArrowRight'] || keys['KeyD'];
        
        if (leftThrust) {
            ctx.fillStyle = '#ff9900';
            ctx.beginPath();
            ctx.moveTo(x + LANDER_W/2, y);
            ctx.lineTo(x + LANDER_W/2 + 10 + Math.random() * 5, y);
            ctx.lineTo(x + LANDER_W/2, y + 6);
            ctx.closePath();
            ctx.fill();
        }
        if (rightThrust) {
            ctx.fillStyle = '#ff9900';
            ctx.beginPath();
            ctx.moveTo(x - LANDER_W/2, y);
            ctx.lineTo(x - LANDER_W/2 - 10 - Math.random() * 5, y);
            ctx.lineTo(x - LANDER_W/2, y + 6);
            ctx.closePath();
            ctx.fill();
        }
    }
    
    function drawHUD() {
        const level = LEVELS[currentLevel];
        
        // Boss health bar (isolado - s√≥ aparece se bossActive)
        if (bossActive && bossData && !bossData.defeated) {
            const barWidth = 300;
            const barHeight = 20;
            const barX = W / 2 - barWidth / 2;
            const barY = 15;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.beginPath();
            ctx.roundRect(barX, barY, barWidth, barHeight, 10);
            ctx.fill();
            
            // Health bar
            const healthPct = bossData.health / bossData.maxHealth;
            let healthColor = '#4CAF50';
            if (healthPct < 0.66) healthColor = '#ffeb3b';
            if (healthPct < 0.33) healthColor = '#ff5252';
            
            ctx.fillStyle = healthColor;
            ctx.beginPath();
            ctx.roundRect(barX + 2, barY + 2, (barWidth - 4) * healthPct, barHeight - 4, 8);
            ctx.fill();
            
            // Border
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Text
            ctx.font = 'bold 14px sans-serif';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText('BOSS', W / 2, barY + 15);
            ctx.textAlign = 'left';
            
            // Shoot indicator
            const canShoot = (Date.now() - lastShotTime) > SHOOT_COOLDOWN;
            ctx.font = '12px sans-serif';
            ctx.fillStyle = canShoot ? '#4CAF50' : '#888';
            ctx.fillText('X/Shift = Shoot', W - 120, 35);
        }
        
        // Main HUD panel
        ctx.fillStyle = 'rgba(15, 20, 30, 0.9)';
        ctx.beginPath();
        ctx.roundRect(10, 10, 180, 145, 8);
        ctx.fill();
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Level name
        ctx.font = 'bold 16px sans-serif';
        ctx.fillStyle = '#4CAF50';
        ctx.textAlign = 'left';
        ctx.fillText(level.name, 20, 32);
        
        // Altitude
        const alt = Math.max(0, Math.floor(PAD_Y - (lander.y + LANDER_H/2)));
        ctx.font = '15px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(t('altitude') + ':', 20, 55);
        ctx.fillStyle = '#fff';
        ctx.fillText(alt + 'm', 70, 55);
        
        // Speed gauge
        const totalSpeed = Math.sqrt(lander.vx*lander.vx + lander.vy*lander.vy) * 100;
        const speedColor = totalSpeed < level.safeSpeed * 0.7 ? '#4CAF50' : 
                          totalSpeed < level.safeSpeed ? '#ffeb3b' : '#ff5252';
        ctx.fillStyle = '#888';
        ctx.fillText(t('speed') + ':', 20, 78);
        ctx.fillStyle = speedColor;
        ctx.fillText(Math.floor(totalSpeed), 70, 78);
        
        // Speed bar
        ctx.fillStyle = '#333';
        ctx.fillRect(100, 68, 70, 12);
        const speedPct = Math.min(1, totalSpeed / (level.safeSpeed * 1.5));
        ctx.fillStyle = speedColor;
        ctx.fillRect(100, 68, 70 * speedPct, 12);
        ctx.strokeStyle = '#555';
        ctx.strokeRect(100, 68, 70, 12);
        
        // Fuel bar
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.roundRect(20, 95, 150, 18, 4);
        ctx.fill();
        const fuelPct = lander.fuel / level.fuel;
        ctx.fillStyle = fuelPct > 0.3 ? '#4CAF50' : fuelPct > 0.15 ? '#ffeb3b' : '#ff5252';
        ctx.beginPath();
        ctx.roundRect(20, 95, 150 * fuelPct, 18, 4);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = '11px sans-serif';
        ctx.fillText(`${t('fuel')}: ${Math.floor(lander.fuel)}`, 25, 108);
        
        // Direction indicator
        const dirToPad = padX + PAD_W/2 - lander.x;
        ctx.font = '13px sans-serif';
        if (Math.abs(dirToPad) > PAD_W) {
            ctx.fillStyle = '#ffeb3b';
            ctx.fillText(dirToPad > 0 ? 'Target ‚Üí' : '‚Üê Target', 20, 140);
        } else {
            ctx.fillStyle = '#4CAF50';
            ctx.fillText('‚úì Aligned', 20, 140);
        }
        
        // Power-up indicators
        let iconX = 130;
        if (lander.shield) {
            ctx.fillStyle = '#2196F3';
            ctx.font = '18px sans-serif';
            ctx.fillText('üõ°', iconX, 140);
            iconX -= 25;
        }
        if (lander.slowmo) {
            // √çcone do slowmo com brilho pulsante
            const pulse = 0.8 + Math.sin(Date.now()/100) * 0.2;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#9C27B0';
            ctx.fillStyle = `rgba(156, 39, 176, ${pulse})`;
            ctx.font = 'bold 22px sans-serif';
            ctx.fillText('‚è±', iconX, 140);
            ctx.shadowBlur = 0;
            
            // Texto explicativo abaixo do √≠cone
            ctx.fillStyle = '#9C27B0';
            ctx.font = 'bold 10px sans-serif';
            ctx.fillText('SLOW', iconX - 8, 155);
        }
        
        // Mini radar (top right)
        ctx.fillStyle = 'rgba(15, 20, 30, 0.9)';
        ctx.beginPath();
        ctx.roundRect(W - 90, 10, 80, 80, 8);
        ctx.fill();
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Radar content
        const radarScale = 70 / W;
        const radarX = W - 85;
        const radarY = 15;
        
        // Pad on radar
        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(radarX + (padX + PAD_W/2) * radarScale - 3, radarY + 60, 6, 3);
        
        // Lander on radar
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(radarX + lander.x * radarScale, radarY + lander.y * (70/H), 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Obstacles on radar
        ctx.fillStyle = '#ff5252';
        obstacles.forEach(obs => {
            ctx.beginPath();
            ctx.arc(radarX + obs.x * radarScale, radarY + obs.y * (70/H), 2, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // Danger warning flash
        if (totalSpeed > level.safeSpeed && lander.y > H/2) {
            flashAlpha = Math.sin(Date.now() / 100) * 0.15 + 0.1;
            flashColor = '#ff0000';
        }
    }
    
    function drawMascot() {
        if (mascotTimer <= 0) return;
        
        const alpha = Math.min(1, mascotTimer / 30);
        ctx.save();
        ctx.globalAlpha = alpha;
        
        // Speech bubble
        const bubbleX = W - 180;
        const bubbleY = H - 100;
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.beginPath();
        ctx.roundRect(bubbleX, bubbleY, 160, 50, 10);
        ctx.fill();
        
        // Tail
        ctx.beginPath();
        ctx.moveTo(bubbleX + 20, bubbleY + 50);
        ctx.lineTo(bubbleX + 10, bubbleY + 70);
        ctx.lineTo(bubbleX + 40, bubbleY + 50);
        ctx.closePath();
        ctx.fill();
        
        // Text
        ctx.fillStyle = '#333';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(mascotMessage, bubbleX + 80, bubbleY + 30);
        
        // Alien mascot
        ctx.fillStyle = '#4CAF50';
        ctx.beginPath();
        ctx.ellipse(bubbleX, bubbleY + 75, 20, 25, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(bubbleX - 7, bubbleY + 70, 5, 7, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(bubbleX + 7, bubbleY + 70, 5, 7, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye shine
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(bubbleX - 5, bubbleY + 68, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(bubbleX + 9, bubbleY + 68, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Antenna
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bubbleX, bubbleY + 50);
        ctx.quadraticCurveTo(bubbleX - 5, bubbleY + 40, bubbleX - 10, bubbleY + 45);
        ctx.stroke();
        ctx.fillStyle = '#ffeb3b';
        ctx.beginPath();
        ctx.arc(bubbleX - 10, bubbleY + 45, 4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    function drawTutorial() {
        if (!showTutorial || tutorialStep > 2) return;
        
        const messages = [t('tut1'), t('tut2'), t('tut3')];
        const msg = messages[tutorialStep];
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.beginPath();
        ctx.roundRect(W/2 - 200, H/2 - 30, 400, 60, 10);
        ctx.fill();
        
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(msg, W/2, H/2 + 5);
    }
    
    // ============================================
    // MENU SCREENS
    // ============================================
    function drawMenu() {
        drawBackground('moon');
        
        // Info panel - top right corner, more compact
        const bestMoon = highScores.moon[0] || 0;
        const bestMars = highScores.mars[0] || 0;
        const bestEarth = highScores.earth[0] || 0;
        
        const panelX = W - 170;
        const panelY = 20;
        const panelW = 150;
        const panelH = 85;
        
        ctx.fillStyle = 'rgba(15, 20, 30, 0.75)';
        ctx.beginPath();
        ctx.roundRect(panelX, panelY, panelW, panelH, 8);
        ctx.fill();
        
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#4CAF50';
        ctx.textAlign = 'left';
        ctx.fillText(t('highscore'), panelX + 8, panelY + 20);
        
        ctx.font = '12px sans-serif';
        ctx.fillStyle = '#bbb';
        ctx.fillText(`üåô ${bestMoon}`, panelX + 8, panelY + 38);
        ctx.fillText(`üî¥ ${bestMars}`, panelX + 8, panelY + 53);
        ctx.fillText(`üåç ${bestEarth}`, panelX + 8, panelY + 68);
        
        // Controls - inline with scores, more compact
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#777';
        const audioIcon = audio.muted ? 'üîá' : 'üîä';
        const langText = lang === 'en' ? 'Magyar' : 'English';
        ctx.fillText(`M=${audioIcon} L=${langText}`, panelX + 8, panelY + 82);
        
        // Title with glow
        ctx.shadowColor = '#4CAF50';
        ctx.shadowBlur = 20;
        ctx.font = 'bold 56px sans-serif';
        ctx.fillStyle = '#4CAF50';
        ctx.textAlign = 'center';
        ctx.fillText('üöÄ ' + t('title'), W/2, 100);
        ctx.shadowBlur = 0;
        
        ctx.font = '28px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(t('subtitle'), W/2, 145);
        
        // Menu items - centered, better spacing
        const items = [t('play'), t('levels'), t('tutorial'), t('explore'), t('info')];
        const menuStartY = 220;
        const menuSpacing = 65;
        
        items.forEach((item, i) => {
            const y = menuStartY + i * menuSpacing;
            
            if (i === menuSel) {
                ctx.fillStyle = 'rgba(76, 175, 80, 0.15)';
                ctx.beginPath();
                ctx.roundRect(W/2 - 120, y - 25, 240, 50, 8);
                ctx.fill();
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            ctx.font = 'bold 28px sans-serif';
            ctx.fillStyle = i === menuSel ? '#4CAF50' : '#fff';
            ctx.textAlign = 'center';
            ctx.fillText(item, W/2, y + 8);
        });
        
        // Mobile navigation hints
        if (isMobile) {
            ctx.font = '14px sans-serif';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.fillText('Swipe ‚Üë‚Üì to navigate | Tap to select', W/2, H - 60);
        }
        
        ctx.textAlign = 'left';
    }
    
    function drawLevelSelect() {
        drawBackground('mars');
        
        ctx.font = 'bold 42px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.fillText(t('levels'), W/2, 70);
        
        // Grid de n√≠veis (3 colunas, linhas conforme necess√°rio)
        for (let i = 0; i < LEVELS.length; i++) {
            const col = i % 3;
            const row = Math.floor(i / 3);
            const x = 200 + col * 200;
            const y = 150 + row * 110;
            const level = LEVELS[i];
            const unlocked = i === 0 || highScores[LEVELS[i-1]?.planet]?.length > 0 || true; // Unlocked for demo
            
            // Card background
            ctx.fillStyle = i === levelSel ? 'rgba(76, 175, 80, 0.3)' : 'rgba(30, 30, 50, 0.8)';
            ctx.beginPath();
            ctx.roundRect(x - 70, y - 35, 140, 80, 8);
            ctx.fill();
            
            if (i === levelSel) {
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Planet icon
            const icons = { moon: 'üåô', mars: 'üî¥', earth: 'üåç' };
            ctx.font = '24px sans-serif';
            if (level.boss) {
                ctx.fillText('üëæ', x - 40, y + 5); // Boss icon
            } else {
                ctx.fillText(icons[level.planet], x - 40, y + 5);
            }
            
            // Level name
            ctx.font = 'bold 18px sans-serif';
            ctx.fillStyle = unlocked ? (i === levelSel ? '#4CAF50' : '#fff') : '#666';
            ctx.fillText(level.name, x + 15, y);
            
            // Difficulty indicator
            ctx.font = '12px sans-serif';
            ctx.fillStyle = '#888';
            if (level.boss) {
                ctx.fillStyle = '#9c27b0';
                ctx.fillText('BOSS', x + 15, y + 20);
            } else {
                const diff = ['Easy', 'Med', 'Hard'][i % 3];
                ctx.fillText(diff, x + 15, y + 20);
            }
            
            // Best score
            if (highScores[level.planet]?.length > 0) {
                ctx.fillStyle = '#ffeb3b';
                ctx.fillText('‚≠ê' + highScores[level.planet][0], x + 15, y + 35);
            }
        }
        
        // Back button
        ctx.font = '24px sans-serif';
        ctx.fillStyle = levelSel === LEVELS.length - 1 ? '#4CAF50' : '#888';
        ctx.fillText(t('back'), W/2, H - 40);
        
        // Mobile navigation hint
        if (isMobile) {
            ctx.font = '14px sans-serif';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.fillText('Swipe to navigate | Tap level to play', W/2, H - 60);
        }
        
        ctx.textAlign = 'left';
    }
    
    function drawSuccess() {
        const level = LEVELS[currentLevel];
        drawBackground(level.planet);
        
        // Confetti effect - mais confetti quando completa todas as fases
        const hasNextLevel = currentLevel < LEVELS.length - 1;
        const allLevelsCompleted = completedLevels.size === LEVELS.length; // Verifica se TODOS os 9 n√≠veis foram completados
        const confettiRate = allLevelsCompleted ? 0.8 : (hasNextLevel ? 0.3 : 0.5); // Mais confetti na conclus√£o final
        if (Math.random() < confettiRate) {
            particles.emitConfetti(Math.random() * W, -20);
        }
        particles.draw(ctx);
        
        // Tela especial de conclus√£o APENAS quando completa TODAS as fases na sequ√™ncia
        if (!hasNextLevel && allLevelsCompleted) {
            // Tela de conclus√£o especial
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 30;
            ctx.font = 'bold 64px sans-serif';
            ctx.fillStyle = '#ffd700';
            ctx.textAlign = 'center';
            ctx.fillText('üéâ ' + (lang === 'hu' ? 'MINDEN SZINTET TELJES√çTETT√âL!' : 'ALL LEVELS COMPLETED!'), W/2, 120);
            ctx.shadowBlur = 0;
            
            ctx.font = 'bold 48px sans-serif';
            ctx.fillStyle = '#4CAF50';
            ctx.fillText('‚úì ' + t('success'), W/2, 180);
            
            ctx.font = 'bold 32px sans-serif';
            ctx.fillStyle = '#ffeb3b';
            ctx.fillText(`${t('score')}: ${score}`, W/2, 250);
            
            ctx.font = '28px sans-serif';
            ctx.fillStyle = '#ffd700';
            ctx.fillText(`${t('total')}: ${totalScore}`, W/2, 300);
            
            ctx.font = '22px sans-serif';
            ctx.fillStyle = '#aaa';
            ctx.fillText(lang === 'hu' ? 'Gratul√°lunk! Te vagy az igazi ≈±rhaj√≥s!' : 'Congratulations! You are a true astronaut!', W/2, 350);
            
            ctx.font = 'bold 22px sans-serif';
            ctx.fillStyle = menuSel === 0 ? '#4CAF50' : '#888';
            ctx.fillText('‚åÇ ' + t('menu'), W/2, 420);
        } else {
            // Tela de sucesso normal para n√≠veis intermedi√°rios
            ctx.shadowColor = '#4CAF50';
            ctx.shadowBlur = 20;
            ctx.font = 'bold 52px sans-serif';
            ctx.fillStyle = '#4CAF50';
            ctx.textAlign = 'center';
            ctx.fillText('‚úì ' + t('success'), W/2, 150);
            ctx.shadowBlur = 0;
            
            ctx.font = 'bold 36px sans-serif';
            ctx.fillStyle = '#ffeb3b';
            ctx.fillText(`${t('score')}: ${score}`, W/2, 230);
            
            ctx.font = '24px sans-serif';
            ctx.fillStyle = '#888';
            ctx.fillText(`${t('total')}: ${totalScore}`, W/2, 280);
            
            ctx.font = 'bold 22px sans-serif';
            ctx.fillStyle = menuSel === 0 ? '#4CAF50' : '#888';
            ctx.fillText('‚Üí ' + t('nextLevel'), W/2, 360);
            ctx.fillStyle = menuSel === 1 ? '#4CAF50' : '#888';
            ctx.fillText('‚åÇ ' + t('menu'), W/2, 400);
        }
        
        ctx.fillStyle = '#666';
        ctx.font = '18px sans-serif';
        ctx.fillText(t('again'), W/2, 460);
        ctx.textAlign = 'left';
    }
    
    function drawFailure() {
        const level = LEVELS[currentLevel];
        drawBackground(level.planet);
        particles.draw(ctx);
        
        ctx.shadowColor = '#ff5252';
        ctx.shadowBlur = 20;
        ctx.font = 'bold 52px sans-serif';
        ctx.fillStyle = '#ff5252';
        ctx.textAlign = 'center';
        ctx.fillText('‚úó ' + t('failure'), W/2, 160);
        ctx.shadowBlur = 0;
        
        ctx.font = '28px sans-serif';
        ctx.fillStyle = '#ffeb3b';
        const reasons = { tooFast: t('tooFast'), noFuel: t('noFuel'), missed: t('missed'), hit: t('hit') };
        ctx.fillText(reasons[failReason] || failReason, W/2, 250);
        
        ctx.font = '22px sans-serif';
        ctx.fillStyle = '#888';
        ctx.fillText(t('mascot_try'), W/2, 320);
        
        ctx.fillStyle = '#666';
        ctx.font = '18px sans-serif';
        ctx.fillText(t('again'), W/2, 400);
        ctx.textAlign = 'left';
    }
    
    function drawExplore() {
        drawBackground('moon');
        
        // Cards data
        const cards = [
            {
                icon: '‚¨áÔ∏è',
                title: t('explore_gravity_title'),
                text: t('explore_gravity_text'),
                color: '#4CAF50',
                x: 120,
                y: 120
            },
            {
                icon: 'üåô',
                title: t('explore_moon_title'),
                text: t('explore_moon_text'),
                color: '#b4b4be',
                x: 520,
                y: 120
            },
            {
                icon: 'üî¥',
                title: t('explore_mars_title'),
                text: t('explore_mars_text'),
                color: '#c86432',
                x: 120,
                y: 300
            },
            {
                icon: 'üåç',
                title: t('explore_earth_title'),
                text: t('explore_earth_text'),
                color: '#3c8cc8',
                x: 520,
                y: 300
            }
        ];
        
        // If a card is selected, show expanded modal
        if (exploreCardSelected >= 0 && exploreCardSelected < cards.length) {
            const card = cards[exploreCardSelected];
            
            // Dark overlay with subtle gradient
            const overlayGrad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H));
            overlayGrad.addColorStop(0, 'rgba(0, 0, 0, 0.7)');
            overlayGrad.addColorStop(1, 'rgba(0, 0, 0, 0.85)');
            ctx.fillStyle = overlayGrad;
            ctx.fillRect(0, 0, W, H);
            
            // Large modal
            const modalW = 720;
            const modalH = 480;
            const modalX = (W - modalW) / 2;
            const modalY = (H - modalH) / 2;
            
            // Modal shadow/glow
            ctx.shadowColor = card.color;
            ctx.shadowBlur = 30;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Modal background with subtle gradient
            const bgGrad = ctx.createLinearGradient(modalX, modalY, modalX, modalY + modalH);
            bgGrad.addColorStop(0, 'rgba(20, 25, 35, 0.98)');
            bgGrad.addColorStop(1, 'rgba(15, 18, 28, 0.98)');
            ctx.fillStyle = bgGrad;
            ctx.beginPath();
            ctx.roundRect(modalX, modalY, modalW, modalH, 24);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // Modal border with gradient effect
            ctx.strokeStyle = card.color;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Inner border highlight
            ctx.strokeStyle = card.color + '40';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(modalX + 2, modalY + 2, modalW - 4, modalH - 4, 22);
            ctx.stroke();
            
            // Icon with subtle glow
            ctx.shadowColor = card.color;
            ctx.shadowBlur = 20;
            ctx.font = '90px sans-serif';
            ctx.fillText(card.icon, W/2, modalY + 95);
            ctx.shadowBlur = 0;
            
            // Title with better spacing
            ctx.font = 'bold 38px sans-serif';
            ctx.fillStyle = card.color;
            ctx.textAlign = 'center';
            ctx.fillText(card.title, W/2, modalY + 155);
            
            // Subtle divider line
            ctx.strokeStyle = card.color + '30';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(modalX + 60, modalY + 180);
            ctx.lineTo(modalX + modalW - 60, modalY + 180);
            ctx.stroke();
            
            // Full text (larger, better formatted)
            ctx.font = '24px sans-serif';
            ctx.fillStyle = '#e0e0e0';
            const words = card.text.split(' ');
            let line = '';
            let y = modalY + 220;
            const maxWidth = modalW - 100;
            const lineHeight = 36;
            
            words.forEach(word => {
                const testLine = line + word + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && line !== '') {
                    ctx.fillText(line, W/2, y);
                    line = word + ' ';
                    y += lineHeight;
                } else {
                    line = testLine;
                }
            });
            ctx.fillText(line, W/2, y);
            
            // Close hint with better styling
            ctx.font = '16px sans-serif';
            ctx.fillStyle = '#999';
            ctx.fillText('Press SPACE or ESC to close', W/2, modalY + modalH - 25);
            
            ctx.textAlign = 'left';
        } else {
            // Show title
            ctx.font = 'bold 42px sans-serif';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText('üîç ' + t('explore'), W/2, 60);
            
            // Show compact cards (icon + title only)
            cards.forEach((card, index) => {
                const isSelected = index === menuSel;
                
                // Card shadow for selected
                if (isSelected) {
                    ctx.shadowColor = card.color;
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }
                
                // Card background with subtle gradient
                const cardGrad = ctx.createLinearGradient(card.x, card.y, card.x, card.y + 140);
                cardGrad.addColorStop(0, isSelected ? 'rgba(25, 30, 40, 0.98)' : 'rgba(20, 25, 35, 0.95)');
                cardGrad.addColorStop(1, isSelected ? 'rgba(18, 23, 33, 0.98)' : 'rgba(15, 20, 30, 0.95)');
                ctx.fillStyle = cardGrad;
                ctx.beginPath();
                ctx.roundRect(card.x, card.y, 320, 140, 14);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // Card border (highlight if selected)
                ctx.strokeStyle = card.color;
                ctx.lineWidth = isSelected ? 4 : 3;
                ctx.stroke();
                
                // Inner border highlight for selected
                if (isSelected) {
                    ctx.strokeStyle = card.color + '40';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.roundRect(card.x + 2, card.y + 2, 316, 136, 12);
                    ctx.stroke();
                }
                
                // Icon with subtle glow when selected
                if (isSelected) {
                    ctx.shadowColor = card.color;
                    ctx.shadowBlur = 10;
                }
                ctx.font = '60px sans-serif';
                ctx.fillText(card.icon, card.x + 160, card.y + 65);
                ctx.shadowBlur = 0;
                
                // Title
                ctx.font = 'bold 26px sans-serif';
                ctx.fillStyle = card.color;
                ctx.textAlign = 'center';
                ctx.fillText(card.title, card.x + 160, card.y + 115);
                
                // Click hint
                ctx.font = '13px sans-serif';
                ctx.fillStyle = isSelected ? '#888' : '#666';
                ctx.fillText('Click to learn more', card.x + 160, card.y + 135);
            });
            
            // Back button
            ctx.font = '24px sans-serif';
            ctx.fillStyle = '#888';
            ctx.textAlign = 'center';
            ctx.fillText(t('back'), W/2, H - 30);
            ctx.textAlign = 'left';
        }
    }
    
    function drawInfo() {
        drawBackground('earth');
        
        ctx.font = 'bold 38px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.fillText(t('info'), W/2, 70);
        
        const lines = [
            'üéì Educational Space Lander Game',
            '',
            'What it teaches:',
            '  ‚Ä¢ Gravity pulls down constantly',
            '  ‚Ä¢ Braking takes time and fuel',
            '  ‚Ä¢ Plan ahead and aim carefully!',
            '',
            'üéÆ Controls:',
            '  ‚Üë/SPACE = Thrust up',
            '  ‚Üê/‚Üí = Move sideways',
            '  M = Toggle sound',
            '',
            'Land slowly on the green pad to win!'
        ];
        
        ctx.font = '18px sans-serif';
        lines.forEach((line, i) => {
            ctx.fillStyle = line.startsWith('What') || line.startsWith('üéÆ') ? '#4CAF50' : '#ccc';
            ctx.fillText(line, W/2, 130 + i * 28);
        });
        
        ctx.fillStyle = '#888';
        ctx.fillText('Press ESC or SPACE to return', W/2, H - 30);
        ctx.textAlign = 'left';
    }
    
    function drawTutorialMode() {
        drawBackground('moon');
        
        const tut = tutorialStep;
        
        // Simple guided tutorial
        ctx.font = 'bold 32px sans-serif';
        ctx.fillStyle = '#4CAF50';
        ctx.textAlign = 'center';
        ctx.fillText(t('tutorial'), W/2, 60);
        
        const steps = [
            { text: t('tut1'), hint: '‚Üë or SPACE', icon: 'üöÄ' },
            { text: t('tut2'), hint: '‚Üê ‚Üí', icon: '‚ÜîÔ∏è' },
            { text: t('tut3'), hint: 'Land gently!', icon: 'üéØ' }
        ];
        
        ctx.font = '24px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(steps[tut].icon + ' ' + steps[tut].text, W/2, 200);
        
        ctx.font = 'bold 36px sans-serif';
        ctx.fillStyle = '#ffeb3b';
        ctx.fillText(steps[tut].hint, W/2, 280);
        
        // Progress dots
        for (let i = 0; i < 3; i++) {
            ctx.fillStyle = i === tut ? '#4CAF50' : '#444';
            ctx.beginPath();
            ctx.arc(W/2 - 30 + i * 30, 350, 8, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.fillStyle = '#888';
        ctx.font = '18px sans-serif';
        ctx.fillText('Press SPACE to continue', W/2, 420);
        ctx.textAlign = 'left';
    }
    
    // ============================================
    // SCREEN EFFECTS
    // ============================================
    function applyScreenShake() {
        if (screenShake > 0) {
            const intensity = screenShake * 0.5;
            ctx.translate(
                (Math.random() - 0.5) * intensity,
                (Math.random() - 0.5) * intensity
            );
            screenShake--;
        }
    }
    
    function drawFlash() {
        if (flashAlpha > 0) {
            ctx.fillStyle = flashColor;
            ctx.globalAlpha = flashAlpha;
            ctx.fillRect(0, 0, W, H);
            ctx.globalAlpha = 1;
            flashAlpha *= 0.9;
        }
    }
    
    function drawTransition() {
        if (transition.active) {
            if (transition.fadeIn) {
                transition.alpha += 0.05;
                if (transition.alpha >= 1) {
                    transition.fadeIn = false;
                    if (transition.callback) transition.callback();
                }
            } else {
                transition.alpha -= 0.05;
                if (transition.alpha <= 0) {
                    transition.active = false;
                }
            }
            ctx.fillStyle = '#000';
            ctx.globalAlpha = transition.alpha;
            ctx.fillRect(0, 0, W, H);
            ctx.globalAlpha = 1;
        }
    }
    
    // ============================================
    // MAIN UPDATE LOOP
    // ============================================
    function update() {
        // Input processing
        for (let k in keys) {
            justPressed[k] = keys[k] && !prevKeys[k];
        }
        
        // Global controls
        if (justPressed['KeyL']) {
            lang = lang === 'en' ? 'hu' : 'en';
            audio.playClick();
        }
        if (justPressed['KeyM']) {
            audio.toggleMute();
            audio.playClick();
        }
        
        // State machine
        if (state === 'menu') {
            if (justPressed['ArrowDown'] || justPressed['KeyS']) { menuSel = (menuSel + 1) % 5; audio.playClick(); }
            if (justPressed['ArrowUp'] || justPressed['KeyW']) { menuSel = (menuSel + 4) % 5; audio.playClick(); }
            if (justPressed['Space'] || justPressed['Enter']) {
                audio.playClick();
                if (menuSel === 0) {
                    completedLevels.clear(); // Reseta os n√≠veis completados ao come√ßar um novo jogo
                    startTransition('playing', () => startLevel(0));
                }
                else if (menuSel === 1) { state = 'levelSelect'; levelSel = 0; }
                else if (menuSel === 2) { state = 'tutorialMode'; tutorialStep = 0; }
                else if (menuSel === 3) { state = 'explore'; exploreCardSelected = -1; menuSel = 0; }
                else state = 'info';
            }
            drawMenu();
        }
        else if (state === 'levelSelect') {
            const maxLevel = LEVELS.length - 1;
            if (justPressed['ArrowRight'] || justPressed['KeyD']) { levelSel = Math.min(maxLevel, levelSel + 1); audio.playClick(); }
            if (justPressed['ArrowLeft'] || justPressed['KeyA']) { levelSel = Math.max(0, levelSel - 1); audio.playClick(); }
            if (justPressed['ArrowDown'] || justPressed['KeyS']) { levelSel = Math.min(maxLevel, levelSel + 3); audio.playClick(); }
            if (justPressed['ArrowUp'] || justPressed['KeyW']) { levelSel = Math.max(0, levelSel - 3); audio.playClick(); }
            if (!transition.active && (justPressed['Space'] || justPressed['Enter'])) {
                audio.playClick();
                if (levelSel < LEVELS.length) {
                    startTransition('playing', () => startLevel(levelSel));
                }
                else state = 'menu';
            }
            if (justPressed['Escape']) { state = 'menu'; audio.playClick(); }
            drawLevelSelect();
        }
        else if (state === 'explore') {
            // Navigation when no card is selected
            if (exploreCardSelected === -1) {
                if (justPressed['ArrowRight'] || justPressed['KeyD']) { 
                    menuSel = (menuSel + 1) % 4; 
                    audio.playClick(); 
                }
                if (justPressed['ArrowLeft'] || justPressed['KeyA']) { 
                    menuSel = (menuSel + 3) % 4; 
                    audio.playClick(); 
                }
                if (justPressed['ArrowDown'] || justPressed['KeyS']) { 
                    menuSel = menuSel < 2 ? menuSel + 2 : menuSel - 2; 
                    audio.playClick(); 
                }
                if (justPressed['ArrowUp'] || justPressed['KeyW']) { 
                    menuSel = menuSel >= 2 ? menuSel - 2 : menuSel + 2; 
                    audio.playClick(); 
                }
                if (justPressed['Space'] || justPressed['Enter']) {
                    exploreCardSelected = menuSel;
                    audio.playClick();
                }
                if (justPressed['Escape']) { 
                    state = 'menu'; 
                    exploreCardSelected = -1;
                    menuSel = 0;
                    audio.playClick(); 
                }
            } else {
                // Card is expanded - close on SPACE/ESC
                if (justPressed['Space'] || justPressed['Escape'] || justPressed['Enter']) {
                    exploreCardSelected = -1;
                    audio.playClick();
                }
            }
            drawExplore();
        }
        else if (state === 'info') {
            drawInfo();
            if (justPressed['Space'] || justPressed['Escape']) { state = 'menu'; audio.playClick(); }
        }
        else if (state === 'tutorialMode') {
            drawTutorialMode();
            if (justPressed['Space'] || justPressed['Enter']) {
                audio.playClick();
                tutorialStep++;
                if (tutorialStep >= 3) {
                    state = 'menu';
                    showTutorial = false;
                }
            }
            if (justPressed['Escape']) { state = 'menu'; audio.playClick(); }
        }
        else if (state === 'playing') {
            // ATALHO DE TESTE: Pressione 'F' para testar a tela final
            if (justPressed['KeyF']) {
                currentLevel = LEVELS.length - 1; // Vai para o √∫ltimo n√≠vel
                // Marca TODOS os n√≠veis como completados para mostrar a tela especial
                for (let i = 0; i < LEVELS.length; i++) {
                    completedLevels.add(i);
                }
                // Simula um pouso bem-sucedido
                score = 1000;
                totalScore = 5000;
                state = 'success';
                menuSel = 0; // Reset menu selection
                audio.playSuccess();
                // M√∫sica removida - apenas efeitos sonoros
            }
            
            const level = LEVELS[currentLevel];
            const gravityMod = lander.slowmo ? 0.3 : 1; // Redu√ß√£o de 70% na gravidade (mais forte!)
            
            // Show/hide shoot button for boss level (isolado)
            const btnShoot = document.getElementById('btnShoot');
            if (btnShoot) {
                if (bossActive && bossData && !bossData.defeated) {
                    btnShoot.style.display = 'flex';
                } else {
                    btnShoot.style.display = 'none';
                }
            }
            
            // ============================================
            // BOSS SYSTEM (Isolado - s√≥ processa se bossActive)
            // ============================================
            // CRITICAL: Check state first - if not playing, skip boss entirely
            if (state !== 'playing') {
                // State changed, clean up boss and skip
                if (bossActive) {
                    bossActive = false;
                    bossData = null;
                    bossBullets = [];
                    playerBullets = [];
                }
            } else if (bossActive && bossData) {
                // Shooting controls (X or Shift) - N√ÉO interfere com Space bar
                const canShoot = (Date.now() - lastShotTime) > SHOOT_COOLDOWN;
                if ((justPressed['KeyX'] || justPressed['ShiftLeft'] || justPressed['ShiftRight']) && canShoot) {
                    playerBullets.push({
                        x: lander.x,
                        y: lander.y - LANDER_H/2,
                        vy: -8,
                        radius: 4
                    });
                    lastShotTime = Date.now();
                    audio.playClick();
                }
                
                // Update boss movement
                bossData.x += bossData.vx;
                if (bossData.x < bossData.width/2 || bossData.x > W - bossData.width/2) {
                    bossData.vx *= -1;
                }
                
                // Update boss health phases
                if (bossData.health > 66) bossData.phase = 1;
                else if (bossData.health > 33) bossData.phase = 2;
                else if (bossData.health > 0) bossData.phase = 3;
                
                // Boss shoots periodically
                bossData.shootTimer++;
                if (bossData.shootTimer > 120 - (bossData.phase * 20)) {
                    bossData.shootTimer = 0;
                    // Boss shoots 2-3 bullets
                    for (let i = 0; i < 2 + bossData.phase; i++) {
                        const angle = Math.PI / 2 + (Math.random() - 0.5) * 0.5;
                        bossBullets.push({
                            x: bossData.x + (Math.random() - 0.5) * 40,
                            y: bossData.y + bossData.height/2,
                            vx: Math.sin(angle) * 2,
                            vy: Math.cos(angle) * 3,
                            radius: 6
                        });
                    }
                }
                
                // Update player bullets
                for (let i = playerBullets.length - 1; i >= 0; i--) {
                    if (state !== 'playing' || !bossData) break; // Safety check
                    
                    const bullet = playerBullets[i];
                    bullet.y += bullet.vy;
                    
                    // Check collision with boss weak points
                    let hit = false;
                    if (bossData && bossData.weakPoints) {
                        for (let wp of bossData.weakPoints) {
                            const wx = bossData.x + wp.x;
                            const wy = bossData.y + wp.y;
                            const dist = Math.sqrt((bullet.x - wx) ** 2 + (bullet.y - wy) ** 2);
                            if (dist < wp.radius + bullet.radius) {
                                bossData.health -= 2;
                                wp.health -= 2;
                                particles.emit(bullet.x, bullet.y, 10, {
                                    angle: 0, spread: Math.PI * 2, speed: 3, life: 20, size: 4,
                                    colors: ['#ffeb3b', '#ff9800', '#ff5722']
                                });
                                audio.playPowerup();
                                hit = true;
                                screenShake = 5;
                                break;
                            }
                        }
                    }
                    
                    if (hit || bullet.y < 0) {
                        playerBullets.splice(i, 1);
                    }
                }
                
                // Update boss bullets
                for (let i = bossBullets.length - 1; i >= 0; i--) {
                    if (state !== 'playing') break; // Safety check
                    
                    const bullet = bossBullets[i];
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    
                    // Check collision with lander
                    const dist = Math.sqrt((bullet.x - lander.x) ** 2 + (bullet.y - lander.y) ** 2);
                    if (dist < bullet.radius + LANDER_W/2) {
                        if (lander.shield) {
                            lander.shield = false;
                            lander.shieldCooldown = 30;
                            particles.emit(lander.x, lander.y, 10, {
                                angle: 0, spread: Math.PI * 2, speed: 3, life: 20, size: 5,
                                colors: ['#4a9eff', '#ffffff']
                            });
                            audio.playPowerup();
                        } else {
                            // Hit by boss bullet
                            failReason = 'hit';
                            particles.emitExplosion(lander.x, lander.y);
                            screenShake = 20;
                            audio.playCrash();
                            state = 'failure';
                            document.getElementById('touchControls').classList.remove('active');
                            // Clean up boss
                            bossActive = false;
                            bossData = null;
                            bossBullets = [];
                            playerBullets = [];
                            break; // Exit bullet loop
                        }
                        bossBullets.splice(i, 1);
                    } else if (bullet.y > H || bullet.x < 0 || bullet.x > W) {
                        bossBullets.splice(i, 1);
                    }
                }
                
                // Check if boss is defeated
                if (bossData && bossData.health <= 0) {
                    // Big explosion
                    particles.emit(bossData.x, bossData.y, 50, {
                        angle: 0, spread: Math.PI * 2, speed: 5, life: 40, size: 8,
                        colors: ['#ff5722', '#ff9800', '#ffeb3b', '#9c27b0']
                    });
                    audio.playSuccess();
                    screenShake = 30;
                    // Pad appears
                    padX = W / 2 - PAD_W / 2;
                    // Mark boss as defeated (allows landing)
                    bossData.defeated = true;
                }
            }
            
            // CRITICAL: Check state before physics - if changed, stop immediately
            if (state !== 'playing') {
                return; // Stop all processing if state changed
            }
            
            // Physics (N√ÉO MODIFICADA - funciona normalmente)
            
            // Physics
            lander.thrust = keys['Space'] || keys['ArrowUp'] || keys['KeyW'];
            const leftMove = keys['ArrowLeft'] || keys['KeyA'];
            const rightMove = keys['ArrowRight'] || keys['KeyD'];
            
            // Apply gravity
            lander.vy += level.gravity * gravityMod;
            
            // Apply wind
            lander.vx += level.wind * (Math.sin(Date.now() / 1000) * 2);
            
            // Apply thrust
            if (lander.thrust && lander.fuel > 0) {
                lander.vy -= THRUST_POWER[level.planet];
                lander.fuel -= FUEL_RATE;
                particles.emitThrust(lander.x, lander.y + LANDER_H/2);
                if (Math.random() < 0.3) audio.playThrust();
            }
            
            // Horizontal movement
            if (leftMove) {
                lander.vx -= H_MOVE[level.planet];
                particles.emitSideThrust(lander.x + LANDER_W/2, lander.y, 1);
            }
            if (rightMove) {
                lander.vx += H_MOVE[level.planet];
                particles.emitSideThrust(lander.x - LANDER_W/2, lander.y, -1);
            }
            
            // Friction
            lander.vx *= 0.995;
            
            // Update position
            lander.y += lander.vy;
            lander.x += lander.vx;
            
            // Bounds
            if (lander.x < LANDER_W/2) { lander.x = LANDER_W/2; lander.vx = 0; }
            if (lander.x > W - LANDER_W/2) { lander.x = W - LANDER_W/2; lander.vx = 0; }
            if (lander.y < LANDER_H/2) { lander.y = LANDER_H/2; lander.vy = 0; }
            
            // Trail
            trail.push({ x: lander.x, y: lander.y });
            if (trail.length > MAX_TRAIL) trail.shift();
            
            // Power-up timers
            if (lander.shieldTimer > 0) lander.shieldTimer--;
            else lander.shield = false;
            if (lander.slowmoTimer > 0) lander.slowmoTimer--;
            else lander.slowmo = false;
            
            // Spawn power-ups
            spawnPowerup();
            
            // Check collisions
            const collision = checkCollisions();
            if (collision) {
                failReason = collision;
                particles.emitExplosion(lander.x, lander.y);
                screenShake = 20;
                flashAlpha = 0.5;
                flashColor = '#ff0000';
                audio.playCrash();
                state = 'failure';
                document.getElementById('touchControls').classList.remove('active');
                // Clean up boss if active (only boss-specific change)
                if (bossActive) {
                    bossActive = false;
                    bossData = null;
                    bossBullets = [];
                    playerBullets = [];
                }
                // CRITICAL: Stop all processing immediately
                return;
            }
            
            // Don't process anything else if state changed
            if (state !== 'playing') return;
            
            checkPowerupCollision();
            
            // Out of fuel check
            const bottom = lander.y + LANDER_H/2;
            if (lander.fuel <= 0 && lander.vy > 0.5 && bottom < PAD_Y - 80) {
                failReason = 'noFuel';
                particles.emitExplosion(lander.x, lander.y);
                screenShake = 15;
                audio.playCrash();
                state = 'failure';
                document.getElementById('touchControls').classList.remove('active');
                // Stop boss from continuing
                bossActive = false;
                bossData = null;
                bossBullets = [];
                playerBullets = [];
                return; // Exit early
            }
            
            // Check if lander fell off screen or crashed into ground (before landing check)
            if (bottom > H + 50) {
                failReason = 'hit';
                particles.emitExplosion(lander.x, lander.y);
                screenShake = 20;
                audio.playCrash();
                state = 'failure';
                document.getElementById('touchControls').classList.remove('active');
                // Stop boss from continuing
                bossActive = false;
                bossData = null;
                bossBullets = [];
                playerBullets = [];
                return; // Exit early
            }
            
            // Check landing (skip if boss is active and not defeated)
            if (bossActive && bossData && !bossData.defeated) {
                // Can't land until boss is defeated - skip landing check
            } else {
            // N√≠veis f√°ceis: aceita pouso um pouco antes de tocar
            const easyLevels = [0, 1, 2, 3, 6]; // Moon 1-3, Mars 1, Earth 1
            const landingThreshold = easyLevels.includes(currentLevel) ? PAD_Y - 10 : PAD_Y;
            if (bottom >= landingThreshold) {
                const landerLeft = lander.x - LANDER_W/2;
                const landerRight = lander.x + LANDER_W/2;
                const totalSpeed = Math.sqrt(lander.vx*lander.vx + lander.vy*lander.vy) * 100;
                
                // Toler√¢ncia horizontal maior nos n√≠veis f√°ceis
                let horizontalTolerance = 15;
                if (currentLevel === 0) horizontalTolerance = 80; // Moon 1 - extremamente f√°cil
                else if (currentLevel === 1) horizontalTolerance = 60; // Moon 2 - muito f√°cil
                else if (currentLevel === 2) horizontalTolerance = 50; // Moon 3 - f√°cil
                else if (currentLevel === 3) horizontalTolerance = 45; // Mars 1 - f√°cil
                else if (currentLevel === 4) horizontalTolerance = 35; // Mars 2 - mais obst√°culos, pouso mais f√°cil
                else if (currentLevel === 5) horizontalTolerance = 30; // Mars 3 - mais obst√°culos, pouso mais f√°cil
                else if (currentLevel === 6) horizontalTolerance = 40; // Earth 1 - f√°cil
                else if (currentLevel === 7) horizontalTolerance = 30; // Earth 2 - mais obst√°culos, pouso mais f√°cil
                else if (currentLevel === 8) horizontalTolerance = 25; // Earth 3 - mais obst√°culos, pouso mais f√°cil
                
                if (landerLeft >= padX - horizontalTolerance && landerRight <= padX + PAD_W + horizontalTolerance) {
                    if (totalSpeed <= level.safeSpeed) {
                        // Success!
                        const fuelBonus = Math.floor(lander.fuel * 10);
                        const speedBonus = Math.floor((level.safeSpeed - totalSpeed) * 20);
                        const accuracyBonus = Math.floor((1 - Math.abs(lander.x - (padX + PAD_W/2)) / (PAD_W/2)) * 300);
                        score = fuelBonus + speedBonus + accuracyBonus;
                        totalScore += score;
                        
                        // Save high score
                        highScores[level.planet].push(score);
                        highScores[level.planet].sort((a, b) => b - a);
                        highScores[level.planet] = highScores[level.planet].slice(0, 3);
                        localStorage.setItem('spaceLanderScores', JSON.stringify(highScores));
                        
                        particles.emitSuccess(lander.x, lander.y);
                        audio.playSuccess();
                        menuSel = 0;
                        // Marca este n√≠vel como completo
                        completedLevels.add(currentLevel);
                        state = 'success';
                        document.getElementById('touchControls').classList.remove('active');
                        // M√∫sica removida - apenas efeitos sonoros
                        return; // Exit immediately after success
                    } else {
                        failReason = 'tooFast';
                        particles.emitExplosion(lander.x, lander.y);
                        screenShake = 15;
                        audio.playCrash();
                        state = 'failure';
                        document.getElementById('touchControls').classList.remove('active');
                        // Clean up boss if active
                        if (bossActive) {
                            bossActive = false;
                            bossData = null;
                            bossBullets = [];
                            playerBullets = [];
                        }
                        return; // Exit immediately after failure
                    }
                } else {
                    failReason = 'missed';
                    particles.emitExplosion(lander.x, lander.y);
                    screenShake = 15;
                    audio.playCrash();
                    state = 'failure';
                    document.getElementById('touchControls').classList.remove('active');
                    // Clean up boss if active
                    if (bossActive) {
                        bossActive = false;
                        bossData = null;
                        bossBullets = [];
                        playerBullets = [];
                    }
                    return; // Exit immediately after failure
                }
            }
            } // End of landing check (boss check)
            
            // Don't process anything else if state changed
            if (state !== 'playing') return;
            
            // Tutorial auto-advance
            if (showTutorial && tutorialStep <= 2) {
                if (tutorialStep === 0 && lander.thrust) tutorialStep = 1;
                else if (tutorialStep === 1 && (leftMove || rightMove)) tutorialStep = 2;
                else if (tutorialStep === 2 && lander.y > H/2) tutorialStep = 3;
            }
            
            updateMascot();
            
            if (justPressed['Escape']) {
                state = 'menu';
                audio.playClick();
                document.getElementById('touchControls').classList.remove('active');
            }
            
            // Drawing
            ctx.save();
            applyScreenShake();
            
            drawBackground(level.planet);
            drawTerrain(level.planet);
            drawTrail();
            // Pad only appears if boss is defeated or no boss
            if (!bossActive || (bossData && bossData.defeated)) {
                drawPad();
            }
            drawObstacles();
            drawPowerups();
            // Draw boss and bullets (isolado - s√≥ aparece se bossActive e state ainda √© 'playing')
            if (state === 'playing' && bossActive && bossData) {
                drawBoss();
                drawBossBullets();
            }
            particles.update();
            particles.draw(ctx);
            drawLander();
            drawHUD();
            drawTutorial();
            drawMascot();
            drawFlash();
            
            // Efeito visual de slow motion na tela toda
            if (lander.slowmo) {
                // Overlay roxo suave na tela toda
                ctx.fillStyle = `rgba(156, 39, 176, ${0.08 + Math.sin(Date.now()/200) * 0.04})`;
                ctx.fillRect(0, 0, W, H);
                
                // Bordas brilhantes
                ctx.strokeStyle = `rgba(200, 100, 255, ${0.3 + Math.sin(Date.now()/150) * 0.2})`;
                ctx.lineWidth = 4;
                ctx.strokeRect(2, 2, W - 4, H - 4);
            }
            
            ctx.restore();
        }
        else if (state === 'success') {
            const hasNextLevel = currentLevel < LEVELS.length - 1;
            if (justPressed['ArrowUp'] || justPressed['ArrowDown']) {
                menuSel = menuSel === 0 ? 1 : 0;
                audio.playClick();
            }
            if (justPressed['Space'] || justPressed['Enter']) {
                audio.playClick();
                if (menuSel === 0 && hasNextLevel) {
                    startTransition('playing', () => startLevel(currentLevel + 1));
                } else {
                    state = 'menu';
                }
            }
            drawSuccess();
            particles.update();
        }
        else if (state === 'failure') {
            if (!transition.active && (justPressed['Space'] || justPressed['Enter'])) {
                audio.playClick();
                startTransition('playing', () => startLevel(currentLevel));
            }
            if (justPressed['Escape']) {
                state = 'menu';
                audio.playClick();
            }
            drawFailure();
            particles.update();
        }
        
        drawTransition();
        
        prevKeys = { ...keys };
        requestAnimationFrame(update);
    }
    
    // ============================================
    // INITIALIZATION
    // ============================================
    function init() {
        detectMobile();
        setupTouchControls();
        setupMenuControls();
        
        // Handle resize
        window.addEventListener('resize', () => {
            detectMobile();
        });
        
        // Start game loop
        update();
    }
    
    init();
    </script>
</body>
</html>
